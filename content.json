{"meta":{"title":"墨夜","subtitle":null,"description":null,"author":"inkn","url":"inknight.cn"},"pages":[{"title":"about","date":"2018-12-29T13:15:42.000Z","updated":"2018-12-29T13:21:17.235Z","comments":true,"path":"about/index.html","permalink":"inknight.cn/about/index.html","excerpt":"","text":"正在学前端的菜鸟💦"},{"title":"tags","date":"2018-12-29T13:32:12.000Z","updated":"2018-12-31T14:20:02.378Z","comments":true,"path":"tags/index.html","permalink":"inknight.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-12-29T13:33:05.000Z","updated":"2018-12-31T14:19:57.307Z","comments":true,"path":"categories/index.html","permalink":"inknight.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Webpack快速上手","slug":"webpack快速上手","date":"2019-05-07T12:43:08.000Z","updated":"2019-05-15T00:57:46.620Z","comments":true,"path":"2019/05/07/webpack快速上手/","link":"","permalink":"inknight.cn/2019/05/07/webpack快速上手/","excerpt":"什么是 Webpack ？webpack 是一个静态模块打包工具，处理模块依赖生成浏览器可执行的代码。 快速开始","text":"什么是 Webpack ？webpack 是一个静态模块打包工具，处理模块依赖生成浏览器可执行的代码。 快速开始 1.建立工程文件夹，初始化npm init -y 本地安装 webpack npm install webpack webpack-cli -D 调整 package.json移除 main 入口防止意外发布代码，添加 private 确保安装包是私有的。 // package.json&#123; \"name\": \"webpack-demo\", \"version\": \"1.0.0\", \"description\": \"\",+ \"private\": true,- \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"webpack\": \"^4.30.0\", \"webpack-cli\": \"^3.3.2\" &#125;&#125; 在工程目录建立以下文件 /src index.js index.css /dist index.html 安装对应 loader 处理 css npm install css-loader style-loader -D 配置 webpack.config.js const path = require('path')module.exports = &#123; mode: 'development', // 模式 | production(默认) | none entry: &#123; // 入口 index: path.resolve(__dirname, 'src/index.js') &#125;, output: &#123; // 出口 path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] // 注意顺序，从后往前 &#125; ] &#125;&#125; 在 index.js 中引入 index.css import './index.css'··· 在 index.html 中引入打包生成的 bundle.js &lt;html&gt; &lt;head&gt; &lt;title&gt;webpack-demo&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; &lt;body&gt;&lt;/html&gt; 在工程目录使用命令打包 webpack 可打开 /dist/index.html 查看结果 Webpack 核心概念Mode模式可以通过配置 mode 进行配置，用于告知 webpack 使用相应环境的内置优化。 可选值: development 开发环境 production 生产环境 none Entry入口指示 webpack 应从哪个模块开始着手，来作为构建其内部依赖图的开始。 配置方法：entry: string|Array&lt;string&gt;module.exports = &#123; mode: 'development', entry: path.resolve(__dirname, 'src/index.js') &#125; 对象语法配置:module.exports = &#123; mode: 'development', entry: &#123; index: path.resolve(__dirname, 'src/index.js') &#125;&#125; Output我们定义的「入口」是 webpack 打包时的程序入口，而最终编译构建后，真正被浏览器加载的资源文件则是「出口」文件，出口配置 webpack 在哪里输出它所创建的 bundles，和指定 bundles 的名字，默认位置是 ./dist。 配置方法：const path = require('path')module.exports = &#123; mode: 'development', entry: path.resolve(__dirname, 'src/index.js'), output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundule.js' &#125;&#125; 如果配置了多入口，则输出多个 bundle： const path = require('path')module.exports = &#123; mode: 'development', entry: &#123; app: path.resolve(__dirname, 'src/app.js'), vendor: path.resolve(__dirname, 'src/vendor.js') &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].js' &#125;&#125; 以上配置会将 app.js 和 vendor.js 输出到 ./dist/ 目录下， Loaderloader 用于对模块的源代码进行转换。webpack 本身只认识 js 和 json 文件，如果要处理其他类型的文件就需要使用对应的 loader。 loader 配置在 module 属性的 rules 数组中，因为 webpack 把所有文件都看成一个个模块，而 loader 正是用于对模块的源代码进行转换。 配置 loader 两个目标： test: 一个正则表达式，标志带哪些后缀的文件需要被处理。 use: 指定 loader 处理满足 test 条件的文件 可选参数： include/exclude: 正则，手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 const path = require('path')module.exports = &#123; mode: 'development', entry: path.resolve(__dirname, 'src/index.js'), output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;&#125; 该配置指定了所有入口依赖的 css 文件，都会先经过 css-loader 处理，再通过 style-loader 转换成 html 上 &lt;style&gt; 标签。 Pluginsloader 用于转换非 JavaScript 类型的文件，而插件则是用于执行范围更广的任务，包括打包优化、压缩、重新定义环境中的变量等等。使用插件，先 npm 安装，再在配置文件中引入，最后将其实例传递给 plugins 数组属性。 const webpack = require('webpack')module.exports = &#123; // other code plugins: [ new webpack.optimize.UglifyJsPlugin() ]&#125; 搭建开发环境 开发环境讲究调试、测试，希望文件是未压缩与未混淆的。 使用 source map 进行调试使用 webpack 对源代码进行打包后，会对源代码进行压缩、精简、甚至变量名替换，在浏览器中无法对代码进行调试，而使用 sourse map 后，我们可以在浏览器看到源代码，进而可以进行调试。 使用 source map:在配置中添加 devtool 属性，赋值为 source-map 或者 inline-source-map 即可，后者报错信息更加具体，会指示代码的具体错误位置，而 source-map 不会。 module.exports = &#123; // other code devtool: 'source-map'&#125; 使用 webpack-dev-server每次写完代码，还要切到控制台，运行打包命令是件很浪费时间的事情。所以需要使用到 webpack-dev-server 使用方法： ① 安装 webpack-dev-server npm install webpack-dev-server -D ② 修改 webpack.config.js 配置，添加 devServer 属性： module.exports = &#123; // other code module.exports = &#123; devServer: &#123; contentBase: './dist' // 静态服务的内容目录地址 // 访问 http://localhost:8080 会映射成工程目录下的 dist 文件夹（webpack-dev-server 访问的是内存中的文件，此时文件并未真正输出到 dist 目录下） &#125; &#125;&#125; ③ 在 package.json 的 scripts 属性中添加命令： &#123; // other code \"scripts\": &#123; \"dev\": \"webpack-dev-server --open\" &#125;&#125; ④ 运行命令 npm run dev 可以看到当修改文件后，浏览器自动刷新。 此外，webpack-dev-server 还有其他功能，比如开发服务器的端口、热更新模式等等，可以参考 Webpack 搭建生产环境 尽量减少构建包的体积。 配置 optimization在 webpack@4 之前，想做构建优化，需引入不少插件。webpack@4 内置了常用的插件，并将其配置化，主要收敛在 optimization 这个配置项中。其主要配置有: minimize当 mode 配置为 production 时，minimize 默认为 true。若将其设为 false ，则取消引入 uglifyjs-webpack-plugin minimizer配置执行代码压缩的工具，默认为 uglifyjs-webpack-plugin，如需要替换成其他的或新增代码压缩插件，可以手动覆盖：const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");const UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\");module.exports = &#123; // other code optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, // 多进程压缩 sourceMap: true &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) // 优化压缩css ] &#125;&#125;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"inknight.cn/tags/Webpack/"},{"name":"项目构建","slug":"项目构建","permalink":"inknight.cn/tags/项目构建/"}]},{"title":"谈谈AJAX","slug":"ajax","date":"2019-04-07T08:02:21.000Z","updated":"2019-05-24T09:32:06.931Z","comments":true,"path":"2019/04/07/ajax/","link":"","permalink":"inknight.cn/2019/04/07/ajax/","excerpt":"AJAX 是什么？AJAX 全称是 Asynchronous JavaScript and XML ，翻译过来就是异步的 JavaScript 和 XML。Ajax 是一种异步请求数据的 Web 开发技术。它的主要目的是为了提高用户体验。Ajax 可以在浏览器不刷新的情况下去更新页面的一些数据，比如表单验证、搜索框的下拉提示等等。Ajax 请求获取的是数据而不是 HTML 文档，所以节省了网络的带宽。","text":"AJAX 是什么？AJAX 全称是 Asynchronous JavaScript and XML ，翻译过来就是异步的 JavaScript 和 XML。Ajax 是一种异步请求数据的 Web 开发技术。它的主要目的是为了提高用户体验。Ajax 可以在浏览器不刷新的情况下去更新页面的一些数据，比如表单验证、搜索框的下拉提示等等。Ajax 请求获取的是数据而不是 HTML 文档，所以节省了网络的带宽。 AJAX 原理Ajax 的核心就是通过浏览器提供的 XMLHttpRequest 对像向服务器请求数据。 创建 XMLHttpRequest 对象var xhr = new XMLHttpRequest() 但是这样并不兼容 IE7 以下。兼容写法： function getXHR() &#123; var xhr = null; if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest() &#125;else &#123; try &#123; xhr = new ActiveXObject('Msxml2.XMLHTTP') &#125; catch() &#123; try &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP') &#125; catch() &#123; alert(\"浏览器不支持 Ajax !\") &#125; &#125; &#125;&#125; 向服务器发送请求分两步先 open 再 send: 1. xhr.open(method, url, isAsync)2. xhr.send(str) // post 请求会在这将参数传入 method: 请求类型，GET 或 POST url: 请求地址 isAsync: 是否异步请求 注意：POST 请求一定要设置请求头的 Content-type xhr.open('POST', 'http://a.com', true)xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded') 处理请求到的数据xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; document.getElementById('myDiv').innerHTML = xhr.responseText &#125;&#125; readyState: 只读属性, readyState属性记录了ajax调用过程中所有可能的状态。有 0~4 五个状态： 0: 未初始化，尚未调用 open 方法 1：启动，已经调用 open 方法 2：发送，已经调用 send 方法 3：接收，已接收到相应头，还在接收相应内容 4：完成，已接收到全部相应数据 onreadystatechange: onreadystatechange 事件回调方法在 readyState 状态改变时触发。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"深浅拷贝","slug":"深浅拷贝","date":"2019-04-03T02:16:51.000Z","updated":"2019-04-07T00:25:38.100Z","comments":true,"path":"2019/04/03/深浅拷贝/","link":"","permalink":"inknight.cn/2019/04/03/深浅拷贝/","excerpt":"对象的赋值操作其实是对地址的复制，而拷贝就是创建一个新对象然后把原对象的属性复制到这个新对象中。 多个变量指向同一个对象，会导致牵一发而动全身的情况出现。","text":"对象的赋值操作其实是对地址的复制，而拷贝就是创建一个新对象然后把原对象的属性复制到这个新对象中。 多个变量指向同一个对象，会导致牵一发而动全身的情况出现。 var a = &#123; age: 1&#125;var b = ab.age = 2console.log(a.age) // 2 浅拷贝 把对象中的属性复制到新对象中，但是如果这个属性是对象，复制的是地址。 实现很简单，就是遍历对象，然后把对象自身的属性和属性值都对应的放在新对象上。function shallowClone(obj) &#123; // 如果传入参数的不是对象，就返回传入的参数 if(typeof obj !=='object' || obj === null) return obj // obj 是数组的话，返回的新对象也应是数组 var newObj = Array.isArray(obj) ? [] : &#123;&#125; for(var key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key] &#125; &#125; return newObj&#125;var a = &#123;age: 1, foo:&#123;x:100&#125;&#125;var b = shallowClone(a)a.age = 2a.foo.x = 200console.log(b.age) // 1console.log(b.foo) // &#123;x: 200&#125; 常见的浅拷贝拷贝数组 slice() var arr = ['old', 1, 2, 3]var newArr = arr.slice()newArr[0] = 'new'console.log(arr) // [\"old\", 1, 2, 3]console.log(newArr) // [\"new\", 1, 2, 3] concat() var newArr = arr.concat() Object.assign() 浅拷贝对象 Object.assing(target, [obj1,obj2...])将所有可枚举属性的值从一个或多个源对象复制到目标对象中，返回目标对象 var a = &#123;name: '张三'&#125;var b = &#123;age: 20&#125;var p = Object.assign(&#123;&#125;, a, b)console.log(p) // &#123;name: \"张三\", age: 20&#125;a.name = '李四'b.age = 30console.log(p) // &#123;name: \"张三\", age: 20&#125; 展开运算符进行浅拷贝var a = &#123;age:1&#125;var b = &#123;...a&#125;a.age = 2console.log(b.age) // 1 深拷贝 把对象中的属性复制到新对象中，但是如果这个属性是对象，复制的是是对象而不是地址。 拷贝的时候判断一下属性值的类型，如果是对象，递归调用深拷贝函数 function deepClone(obj) &#123; if(!isObj(obj)) throw new Error('非对象') var newObj = Array.isArray(obj) ? [] : &#123;&#125; for( var key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; newObj[key] = isObj(obj[key]) ? deepClone(obj[key]) : obj[key] &#125; &#125; return newObj function isObj(o) &#123; return (typeof o === 'object' || typeof o === 'function') &amp;&amp; o !== null &#125;&#125;var a = &#123;age: 1, foo:&#123;x:100&#125;&#125;var b = deepClone(a)a.age = 2a.foo.x = 200console.log(b.age) // 1console.log(b.foo) // &#123;x: 100&#125; 常见深拷贝先序列化成字符串再反序列化成为新对象 JSON.parse(JSON.stringify(object)) 这个方法简单粗暴，大多数情况下适用 var p = &#123; name: '张三', age: 20, jobs: &#123; name: '程序猿', city: '北京' &#125;&#125;var p2 = JSON.parse(JSON.stringify(p))p2.jobs.city = '深圳'console.log(p.jobs.city) // 北京 但是该方法也是有局限性的： 忽略 undefined 忽略 symbol 忽略函数 包含循环引用的对象执行 JSON.stringify() 会出错 var bar = &#123; a: undefined, b: Symbol('bb'), c: function()&#123;console.log('this is a')&#125;, d: 'd'&#125;var bar2 = JSON.parse(JSON.stringify(bar))console.log(bar2) // &#123;d: \"d\"&#125; 函数库lodash 该函数库提供了 cloneDeep 方法实现深拷贝 深拷贝实现其实很困难的，需要考虑很多边界问题，比如原型链如何处理、Dom 元素的处理。实际开发者如果确定要用深拷贝，可以使用 lodash 库var _ = require(&apos;lodash&apos;)var obj = &#123; a: 1, b: &#123;foo: function()&#125;&#125;var obj2 = _.cloneDeep(obj) 总结 浅拷贝就是在拷贝对象属性时，属性值也是对象的话，拷贝的只是引用，而深拷贝拷贝的是对象。 深拷贝会用到递归，效率低下，能不用则不用。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"手撕代码-JavaScript","slug":"手撕代码-JavaScript","date":"2019-03-29T01:06:17.000Z","updated":"2019-05-15T01:11:26.355Z","comments":true,"path":"2019/03/29/手撕代码-JavaScript/","link":"","permalink":"inknight.cn/2019/03/29/手撕代码-JavaScript/","excerpt":"call 更改函数的 this 指向并执行函数并将结果返回。","text":"call 更改函数的 this 指向并执行函数并将结果返回。 Function.prototype.myCall = function(context) &#123; var context = context || window context.fn = this var args = [] for(var i = 1; i &lt; arguments.length; i++) &#123; args.push('arguments[' + i + ']') &#125; var result = eval('context.fn(' + args + ')') delete context.fn return result&#125; 分析： 首先 context 作为可选参数，如果不传或传 null ，默认上下文为 window 然后给上下文 context 添加方法 fn ，fn 就是要执行的函数，谁调用了 call() , fn 就是谁。 所以 context.fn = this call 还可以传入多个参数作为调用的函数的参数，可以通过 arguments 对象获取函数的参数。 最后调用函数保存返回值，删除给对象添加的 fn ，将结果返回。 核心就是，通过将函数添加到对象上，然后通过对象调用这个函数，从而使函数中的 this 指向这个对象。 更简洁的写法： Function.prototype.myCall = function(context, ...rest) &#123; var context = context || window context.fn = this var result = context.fn(...rest) delete context.fn return result&#125; apply apply 实现与 call 类似，区别在于对参数的处理 Function.prototype.myApply = function(context, arr) &#123; var context = context || window context.fn = this var result if(!arr) &#123; result = context.fn() &#125; else &#123; var args = [] for(var i = 0; i &lt; arr.length; i++) &#123; args.push('arr[' + i + ']') &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result&#125; 简洁：Function.prototype.myApply = function(context, arr) &#123; var context = context || window context.fn = this var res = arr ? context.fn(...arr) : context.fn() delete context.fn return res&#125; bind 创建并返回一个新的改变了 this 的函数。并在调用新函数时，会将在调用 bind 时给定的参数列表作为原函数的参数序列的前若干项。 举个例子：function foo(name,age) &#123; console.log('name:' + name + 'age:' + age)&#125;var f = foo.bind(null,'张三')f(20) // name:张三age:20 实现：Function.prototype.myBind = function(context) &#123; var self = this var args = [].slice.call(arguments, 1) function F() &#123; var args2 = [].slice.call(arguments) var arglist = args.concat(args2) return self.apply(this instanceof F ? this: context, arglist) &#125; F.prototype = Object.create(self.prototype) return F&#125; bind 返回的是一个函数，在这个函数里面返回了 原函数.apply() 实现改变 this 。 如果 bind 返回的新函数作为构造函数执行时(new 函数)，this 不能改成传入的 context ，this 应该是声明的变量。 bind() 传入的除 context 的后续参数，先存起来，在调用由 bind 返回的新函数时 ，向 apply() 传入由原来存的参数和新传入的参数组成的数组(注意顺序)。 简洁： Function.prototype.myBind = function(context, ...rest) &#123; var self = this function F() &#123; return self.apply(this instanceof F ? this : context,rest.concat(...arguments)) &#125; F.prototype = Object.create(self.prototype) return F&#125; new new 运算符创建了一个用户自定义类型的实例 在执行 new 构造函数() 时，发生了： 生成一个新对象 将对象的原型引用(__proto__)指向构造函数的原型 绑定 this 为该对象，执行构造函数中的内容 如果函数执行的返回值是对象，就返回这个对象，否则返回之前创建的新对象 function myNew() &#123; var constructor = [].shift.call(arguments) var obj = Object.create(constructor.prototype) var res = constructor.apply(obj, arguments) return res instanceof Object ? res: obj&#125; 简洁： function myNew(constructor, ...rest) &#123; let obj = Object.create(constructor.prototype) let res = constructor.apply(obj, rest) return res instanceof Object ? res : obj&#125; instanceof 通常能正确判断对象的类型，原理是判断构造函数的原型对象是否能在对象的原型链上 function myInstanceof(obj, fn) &#123; let prototype = fn.prototype let objProto = Object.getPrototypeOf(obj) while(true) &#123; if(objProto == null) return false if(objProto === prototype) return true objProto = Object.getPrototypeOf(objProto) &#125;&#125; 获得构造函数的原型 获得实例对象的原型 判断构造函数的原型是否就是实例对象的原型，如果是就返回 true ，不是就让实例对象的原型指向自身的原型继续判断，直到实例对象的原型为 null，返回 false","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"},{"name":"进阶","slug":"进阶","permalink":"inknight.cn/tags/进阶/"}]},{"title":"ES6 系列 (上)","slug":"ES6上","date":"2019-03-28T12:23:17.000Z","updated":"2019-05-09T00:53:31.458Z","comments":true,"path":"2019/03/28/ES6上/","link":"","permalink":"inknight.cn/2019/03/28/ES6上/","excerpt":"Symbol Symbol 是 ES6 中新增的一种原始类型。","text":"Symbol Symbol 是 ES6 中新增的一种原始类型。 var s1 = Symbol('s')var s2 = Symbol('s')console.log(s1 == s2) // falseconsole.log(typeof s1) // 'symbol' Symbol 类型通过调用 Symbol() 函数生成，每一个 Symbol 类型的值都是唯一的，即使在调用 Symbol() 时传入的参数相同，返回的值并不同。 Symbol 类型能转换成布尔值(true)或字符串，但不能转化成数字 Symbol 类型作为对象的 key 可以私有化属性 普通闭包方式创建有私有属性的构造函数:var Person = (function() &#123; // 私有属性 var _gender function P(name, gender) &#123; this.name = name _gender = gender &#125; P.prototype.getGender = function() &#123; return _gender &#125; P.prototype.setGender = function(n) &#123; _gender = n &#125; return P &#125;)() var p = new Person('张三', '男') console.log(p) // P &#123;name: \"张三\"&#125; console.log(p.getGender()) // 男 p.setGender('女') console.log(p.getGender()) // 女 Symbol + 闭包实现私有化属性：var Person = (function() &#123; var _gender = Symbol('gender') function P(name, gender) &#123; this.name = name this[_gender] = gender &#125; P.prototype.getGender = function() &#123; return this[_gender] &#125; P.prototype.setGender = function(n) &#123; this[_gender] = n &#125; return P&#125;)()var p = new Person('张三', '男')console.log(p[Symbol('gender')]) // undefinedconsole.log(p.getGender()) // 男p.setGender('女')console.log(p.getGender()) // 女 使用 Symbol + 闭包的方式私有化属性会安全。仅使用闭包会出问题，_gender 属性只有一个，所有 Person 实例会共用同一个。 let、constvar 的特点 支持变量声明预解析 不支持块级作用域 可以重复声明 console.log(a) // undefined&#123; var a = 1&#125;console.log(a) // 1var a = 2console.log(a) // 2 let、const 的特点 不支持变量声明预解析 (先声明后使用) 支持块级作用域 不能重复声明 (暂时性死区) &#123; console.log(a) // Uncaught ReferenceError: a is not defined let a = 1 const b = 2&#125;console.log(b) // Uncaught ReferenceError: b is not definedlet c let c = 3 // Uncaught SyntaxError: Identifier 'c' has already been declared 不支持变量预解析和不支持变量的重复声明大大地提高了数据使用的安全性。所以 var 能不用则不用。 在实际开发中这种方法在日益普及：默认使用 const，只有当确实需要改变变量的值的时候才使用 let。因为大部分的变量的值在初始化后不应再改变。 const 常量 声明时就必须初始化 初识化后就不能改变 const a // Uncaught SyntaxError: Missing initializer in const declarationconst b = 1b = 2 // Uncaught TypeError: Assignment to constant variable. const 在存对象的时候，存的是对象的引用(地址)，引用不能改变，但对象的内容却可以。 const p = &#123; name: '张三', age: 20&#125;p.age = 21console.log(p.age) // 21 如果想让对象的属性也不能改变，可以使用 Object.freeze() 方法冻结对象的一层属性 const p = Object.freeze(&#123; name: '张三', age: 20&#125;)console.log(Object.isFrozen(p)) // truep.age = 21 console.log(p.age) // 20 但是如果对象中还有对象，就不行了，只能递归冻结。 解构赋值 按照一定模式，从数组和对象中提取值，并对变量进行赋值。 数组解构 顺序对应 let [a, b, c] = [1, 2, 3]let [d, , e] = [4, 5, 6]console.log(a, b, c, d, e) // 1 2 3 4 6 交换数字：let a = 1let b = 2;[a, b] = [b, a]console.log(a, b) // 2 1a = a ^ bb = a ^ ba = a ^ b console.log(a, b) // 1 2a = a + bb = a - ba = a - bconsole.log(a, b) // 2 1 字符串解构 和数组一样let [char1, char2, char3] = 'abcd'console.log(char1, char2, char3) // a b c 对象解构 变量名要与 key 对应 无顺序 let &#123;a, b, c&#125; = &#123;a: 'aa', b: 'bb'&#125;console.log(a, b, c) // aa bb undefined 别名在对象解构中，可以自定义变量名 let &#123;a: name, b: age&#125; = &#123;a: '张三', b: 20&#125;console.log(name, age) // 张三 20console.log(a) // Uncaught ReferenceError: a is not defined 多重解构let &#123;foo: [a, b]&#125; = &#123;foo:[1, 2], bar: 'bbb'&#125;console.log(a, b) // 1 2 展开运算符 … 把数组或对象展开成参数序列 [‘a’, ‘b’, ‘c’] —&gt; ‘a’, ‘b’, ‘c’{height: 100, width: 200} —&gt; height:100, width: 200 在调用函数传参时，可以将传入的数组转换成参数序列 console.log(Math.max(1, 2, 3)) // 3var arr = [1, 2, 3]console.log(Math.max(...arr)) // 3// =&gt; Math.max(arr[0], arr[1], arr[2]) 数组、对象合并 var arr1 = [1, 2, 3]var arr2 = ['a','b']var arr3 = [...arr1, ...arr2]console.log(arr3) // [1, 2, 3, \"a\", \"b\"]var obj1 = &#123;width: 100, height: 200&#125;var obj2 = &#123;top: 123, width: 200&#125;var obj3 = &#123;...obj1, ...obj2&#125;console.log(obj3) // &#123;width: 200, height: 200, top: 123&#125;var obj4 = &#123;...arr1, ...obj1&#125;console.log(obj4) // &#123;0: 1, 1: 2, 2: 3, width: 100, height: 200&#125;var arr4 = [...arr1, ...obj1] // Uncaught TypeError: obj1 is not iterable 将任意可迭代对象转换成数组 var str = 'abcde'var arr1 = [...str]console.log(arr1) // [\"a\", \"b\", \"c\", \"d\", \"e\"] 模板字符串 保持内容格式 var str = ` &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;`console.log(str)/* &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;*/ 变量表达式解析 ${ } var a = 1var str = `&lt;p&gt;$&#123;a + 123&#125;&lt;p&gt;`console.log(str) // &lt;p&gt;124&lt;p&gt; 字面量语法扩展属性初始值简写 字面量集合中如果键和值名称相同，可以只写键。 function createPerson(name, age) &#123; return &#123; name: name, age: age &#125;&#125;// 简写:function createPerson(name, age) &#123; return &#123; name, age &#125;&#125; 对象方法的简写 可以省略 : 和 function 关键字 var person = &#123; name: 'nick', sayName: function() &#123; console.log(this.name) &#125;&#125;// 简写：var person = &#123; name: 'nick', sayName() &#123; console.log(this.name) &#125;&#125; 迭代器 在标准 for 循环中，通过定义索引变量来追踪当前元素，很简单，但是，当涉及到多重 for 循环嵌套时，代码复杂度增大，容易出错（误用其他循环的索引变量）。迭代器的出现旨在消除这种复杂性。 什么是迭代器迭代器就是一个具有 next() 方法的对象，每次调用 next() 都会返回一个结果对象，结果对象有两个属性， value 表示当前值，done 表示遍历是否结束。 根据上面的规则，我们创建一个迭代器的工厂： function createIterator(items)&#123; var i = 0 return &#123; next() &#123; var done = i &gt;= items.length var value = !done ? items[i++] : undefined return &#123; value, done &#125; &#125; &#125;&#125;var iterator = createIterator([1, 2, 'bar'])console.log(iterator.next()) // &#123;value: 1, done: false&#125;console.log(iterator.next()) // &#123;value: 2, done: false&#125;console.log(iterator.next()) // &#123;value: \"bar\", done: false&#125; for of 除了迭代器以外，我们还需要一个可以遍历迭代器对象的方式，ES6 提供了 for (var value of iterator) 语句。 我们先试着遍历前面自己写的迭代器对象： var iterator = createIterator([1, 2, 'bar'])for (var value of iterator) &#123; console.log(value)&#125;// Uncaught TypeError: iterator is not iterable 我们写的迭代器对象竟然不能被迭代!?? 其实我们还差一步，因为 for(A of B) 语句其实是通过调用对象 B 的 Symbol.iterator 方法来获取迭代器，随后调用迭代器的 next() 方法，将其返回的结果对象的 value 属性赋给变量 A。 所以： var b = &#123;&#125;b[Symbol.iterator] = function() &#123; return createIterator([1, 2, 'bar'])&#125;for (var a of b) &#123; console.log(a)&#125;// 1// 2// bar 默认可迭代对象我们试试直接用 for of 遍历数组 var arr = ['a', 'b', 'c']for (var v of arr) &#123; console.log(arr)&#125;// a// b// c 尽管我们没有手动去添加 arr 的 ‘Symbol.iterator’ 属性，但是还是可以遍历，这是因为 ES6 为数组默认部署了 Symbol.iterator ，我们也可以重写这个方法。 var arr = ['a', 'b', 'c']arr[Symbol.iterator] = function() &#123; return createIterator(['aa', 'bb', 'cc'])&#125;for (var v of arr) &#123; console.log(v)&#125;// aa// bb// cc 除了数组外，还有一些数据结构默认部署了 Symbol.iterator 属性。 默认可以迭代的对象： 数组 字符串 Set Map 类数组对象，如 arguments，DOM 里的 NodeList Generator 对象 箭头函数(参数) =&gt; {函数体}// 只有一个参数可以不写 ()x =&gt; &#123;console.log(x)&#125;// 函数体中只有一条语句可以不写 &#123;&#125; ，该条语句的结果会作为函数的返回值var foo = x =&gt; x*xconsole.log(foo(2)) // 4 内部不绑定 this ，访问外部作用域的 this 。也就是说箭头函数中的 this 在箭头函数定义时就已经确定了。 内部没由 arguments 不能作为构造函数 不能作为生成器函数 Set集合：类似于数组，但成员的值都是唯一的，没有重复的值，并且无序。Set() 是一个构造函数，可以传入一个可迭代对象初始化默认值 数组去重： var arr = [1, 2, 3, 1, 2]arr = [...new Set(arr)]console.log(arr) // [1, 2, 3] Map映射：类似于对象，但是 key 值可以是任意类型的值，而不仅仅局限于字符串。 WeakMap类似 Map ，但 key 必须是对象，并且对 key 这个对象是弱引用的(GC 机制会回收只有弱引用或没有引用的对象)。 可以优化类中私有化属性使用 Map 造成的强引用不能释放问题。 classclass Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; sayHi() &#123; console.log(this.name + ': Hi~') &#125;&#125;var p = new Person('张三', 23)console.log(p) // Person &#123;name: \"张三\", age: 23&#125;p.sayHi() // 张三: Hi~ class 的继承写法： class Student extends Person &#123; constructor(name, gender) &#123; super(name) // 子类有 constructor 就必须要有 super() 不然报错 this.gender = gender &#125;&#125;var s = new Student('小明', '男')console.log(s) // Student &#123;name: \"小明\", age: undefined, gender: \"男\"&#125;s.sayHi() // 小明: Hi~","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"inknight.cn/tags/ECMAScript6/"}]},{"title":"this 指向","slug":"this","date":"2019-03-21T02:31:44.000Z","updated":"2019-05-10T01:01:15.290Z","comments":true,"path":"2019/03/21/this/","link":"","permalink":"inknight.cn/2019/03/21/this/","excerpt":"this 的指向，apply、bind、call 一起搞定~","text":"this 的指向，apply、bind、call 一起搞定~ thisthis 是在执行函数时，创建的上下文对象中的一个属性，它代表该函数的调用者。所以 this 一般是在函数执行时确定的。 this 指向的是谁一般情况下，请记住 “谁调用我，我就代表谁“。谁调用这个函数，函数中的 this 就指向谁。 var name = 'window'function foo() &#123; var name = 'foo' console.log(this.name)&#125;foo() // 'window' 执行 foo() 相当于执行 window.foo()(非严格模式) 也就是 window 调用了 foo 函数，所以 foo 函数体内的 this 指向的就是 window 对象。当然如果是在 Node.js 环境下，上述 this 指向的就是 globle 对象了。 匿名函数中的 this 也是指向全局对象的。 再看个例子：var name = 'window'var a = &#123; name: 'a', foo: function() &#123; console.log(this.name) &#125;&#125;a.foo() // 'a'var foo2 = a.foofoo2() // 'window' 改变 this 的指向new 实例化对象。new 运算符做了：创建一个新对象，将构造函数的 this 指向该对象，执行构造函数代码，如果函数执行结果返回一个对象，就将这个对象返回，否则返回创建的对象。 function User(name) &#123; this.name = name&#125;var a = new User('小a') _this = thisvar name = 'window'var a = &#123; name: 'a', foo: function() &#123; setTimeout(function() &#123; console.log(this.name) &#125;, 0) &#125;, foo2: function() &#123; var _this = this setTimeout(function()&#123; console.log(_this.name) &#125;, 0) &#125;&#125;a.foo() // 'window'a.foo2() // 'a' apply、call、bindapply 与 call 差不多，主要是传参不同，都是将 this 改变并执行函数，而 bind 是将函数返回但没执行。 var name = 'window'var a = &#123; name: 'a', foo: function(x, y) &#123; console.log(this.name + x + y) &#125;&#125;a.foo.call(this, 1, 2) // 'window12'a.foo.apply(this, [1, 2]) // 'window12'var foo2 = a.foo.bind(this, 1, 2)foo2() // 'window12' 箭头函数箭头函数不绑定 this，没有自己的 this ，必须通过作用域链决定其值。也就是箭头函数中的 this 就是父级作用域中的 this var name = 'window'var a = &#123; name: 'a', foo: () =&gt; &#123; console.log(this.name) &#125;, foo2: function() &#123; setTimeout(()=&gt;&#123; console.log(this.name) &#125;, 0) &#125;&#125;a.foo() // 'window'a.foo2() // 'a'","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"JavaScript中的作用域、执行上下文与闭包","slug":"JavaScript中的作用域与闭包","date":"2019-03-18T00:34:44.000Z","updated":"2019-04-10T02:41:02.478Z","comments":true,"path":"2019/03/18/JavaScript中的作用域与闭包/","link":"","permalink":"inknight.cn/2019/03/18/JavaScript中的作用域与闭包/","excerpt":"JavaScript 代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。","text":"JavaScript 代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 作用域 (Scope)什么是作用域作用域是定义变量的区域。 它规定了执行代码时查找变量的范围，也就是变量的作用范围。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 var a = 1function foo1() &#123; console.log(a)&#125;function foo2() &#123; var a = 2 foo1()&#125;foo2() // 1 在 JavaScript 中无块级作用域(一对儿 { } 包含的区域 )，只有全局作用域和函数作用域。 if (true) &#123; var name = 'abc'&#125;console.log(name) // 'abc' 同一个页面中所有的 &lt;script&gt; 标签中的没在函数体内的变量，都在同一个全局作用域中。 执行上下文 (Execution context)什么是执行上下文 执行上下文可以抽象成一个对象，当一个函数执行时就会创建一个执行上下文。 每个执行上下文，都有三个属性： 变量对象(Variable object, VO) 作用域链(Scope chain) this 既然每执行一个函数就会创建一个执行上下文，我们写的函数可不止一个，那么如何管理众多的上下文呢？ JavaScript 引擎创建了执行上下文栈(Execution context stack, ECS) 来管理执行上下文。 JavaScript 引擎在执行代码时，最先遇到的是全局代码，会创建一个全局上下文(globalContext)并将之压入执行上下文栈(ECS)中，当执行一个函数时，创建一个函数上下文并压入 ECS 中。函数执行完毕时，这个函数上下文会出栈并被清理。当整个程序执行完毕时，globalContext 也会出栈并被清理。 看一个例子： function fun1() &#123; fun2()&#125;function fun2() &#123; console.log('fun2')&#125;fun1() 当 JavaScript 引擎执行代码时，先创建一个全局上下文(globalContext) 压入执行上下文栈(ECS)中。 当执行到 fun1() 时，创建一个函数上下文(EC_fun1)并压入栈中。 然后执行 fun1 函数体里的 fun2()，创建 EC_fun2并压入栈中。 执行 fun2 函数里的 console.log() 函数，创建 EC_consolelog 压入栈中。 然后 console.log 执行完毕，EC_consolelog 出栈并销毁。 然后 fun2 执行完毕，EC_fun2 出栈并销毁。 fun1 执行完毕，EC_fun1 出栈并销毁。 变量对象 (Variable object, VO) 变量对象是与执行上下文相关的数据作用域，它存储了在该上下文定义的变量和函数声明。变量对象是在创建函数上下文时创建的，它通过函数的 arguments 属性初识化。 变量对象包括： 函数的所有形参(如果是函数上下文) 由名称和对应值组成一个变量对象(VO)的属性 函数声明 由名称和对应值(函数对象)组成一个变量对象(VO)的属性 如果 VO 已存在相同的名称属性，则替换这个属性 变量声明 由名称和 undefined 组成一个 VO 的属性 如果名称和已经声明的形参或函数相同，变量声明不会干扰已存在的这类属性 举个例子： function foo(a) &#123; var b = 2 var a = 10 function c() &#123;&#125; var d = function() &#123;&#125;&#125;foo(11) 在执行 foo(11)时，创建一个执行上下文，此时执行上下文的变量对象时： VO = &#123; arguments: &#123; 0: 11, length: 1 &#125;, a: 11, b: undefined, c: reference to function c() &#123;&#125;, d: undefined&#125; 全局对象 全局上下文的变量对象就是全局对象。 全局上下文的 this 指向的是全局对象。 在浏览器环境下全局对象是 window ，Node.js 环境下全局对象是 global 。 活动对象 (Activation object，AO)活动对象与变量对象其实是同一个东西，只有当进入一个执行上下文中(这个执行上下文处在执行上下文栈的栈顶)，这个执行上下文的变量对象(VO)才会被激活，此时这个变量对象叫做活动对象(AO)。只有活动对象上的各种属性才能被访问。 作用域链 (Scope chain) 当查找变量时，会在当前执行上下文的变量对象(也是活动对象)中查找，如果没找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象(也是全局对象)。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 函数定义时，有一个内部属性 [[scope]] 保存了所有父变量对象。当函数执行时会创建一个作用域链，这个作用域链包含了函数的 [[scope]] 属性和执行上下文的活动对象(AO)。 var a = 1var b = 1function foo() &#123; var b = 2 return a + b&#125;foo() // 3 执行过程如下： foo 函数被创建，foo 会将父变量对象(其实是当前活动对象也是全局对象)保存在 [[scope]] 属性中。 foo.[[scope]] = [globalContext.VO] 执行 foo 函数，创建 foo 函数执行上下文并压入执行上下文栈(ECS)中。 ECS = [ fooContext, globalContext] foo 函数并不立刻执行，需要一些准备工作，第一步：复制函数的 [[scope]] 属性到创建的作用域链(Scope)中 fooContext = &#123; Scope: foo.[[scope]]&#125; 第二步：创建活动对象并用函数的 arguments 属性初始化 fooContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, b: undefined &#125;, Scope: [ foo.[[scope]] ]&#125; 第三步：将活动对象压入 作用域链顶端 fooContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, b: undefined &#125;, Scope: [ AO, foo.[[scope]] ]&#125; 准备工作做完，开始执行 foo 函数里的代码，更新 AO 的属性值 AO:&#123; arguments: &#123; length: 0 &#125;, b: 2&#125; foo 执行完毕，foo 函数上下文出栈并销毁 ECS = [ globalContext ] 闭包什么是闭包MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的变量，但既不是函数参数也不是函数局部变量。 自由变量其实是指函数执行上下文的作用域链中非活动对象的那部分属性(也就是外层作用域的变量 函数.[[scope]]) 所以在《JavaScript高级程序设计中》是这样描述的： 闭包是指有权访问另一个函数作用域中的变量的函数。 var a = 1function foo() &#123; console.log(a)&#125;foo() foo 函数可以访问变量a，但 a 既不是函数参数也不是函数的局部变量，a 就是自由变量。那么，foo 函数就是一个闭包。 到这里，你或许会有疑问 这怎么和我们平时知道的闭包不是同一个，不是什么函数中嵌套一个函数，里面的函数才是一个闭包，这里怎么没有嵌套函数了？ 其实是站的角度不同： 从理论角度：所有函数都是闭包。因为他们都在创建时就将上层执行上下文的数据保存起来了(函数的 [[scope]] 属性)。所以在函数中可以作用域链访问到外层作用域的变量，也就是可以访问自由变量，它就是一个闭包。 从实际角度：以下才是闭包： 即使创建它的上下文已经销毁，但它依然存在(比如，内部函数从父函数中返回) 在代码中引用了自由变量 举个例子：function foo() &#123; var a = 0 return function add() &#123; console.log(a++) &#125;&#125;var add1 = foo()var add2 = foo()add1() // 0add1() // 1add1() // 2add2() // 0add2() // 1 foo() 函数执行完毕，foo函数执行上下文已经被销毁，那么上下文的变量对象中的 a 变量应该也被销毁了啊，问啥还能访问到？ 因为 add 函数在定义时就存在一个 [[scope]] 属性，它保存了 foo 函数执行上下文的变量对象，在执行 add 函数时，会创建一个执行上下文链并将 add.[[scope]] 复制到该执行上下文的作用域链中，所以在 add 函数中可以通过作用域链访问到 a 属性。 你可能还有一个问题，为什么 add1() 和 add2() 访问的不是同一个 a ？因为每执行一次函数就会创建一个函数执行上下文，所以执行 add1 = foo() 和 add2 = foo() 产生的是不同的执行上下文(对象)，他们的 a 属性当然不同了。 闭包的面试题 经典面试题，使用闭包解决 for 循环中 var 异步打印 i 值的问题 for (var i = 0; i &lt; 5 ; i++) &#123; setTimeout(function foo() &#123; console.log(i) &#125;,1000 * i)&#125; 以上代码执行结果是：5 5 5 5 5。 这里面涉及到事件循环机制，这里就不多赘述，简单的说就是等 for 循环结束后，才开始依次执行这几个 setTimeout() 里面的 foo 函数。 JS 没有块级作用域，此时的 i 值为 5 ，console.log(i) 访问的就是全局变量 i ，所以打印 5。 我们要做就是使用闭包的特性，让 console.log(i) 访问的不是全局变量 i for (var i = 0; i &lt; 5 ; i++) &#123; ;(function(i) &#123; setTimeout(function foo() &#123; console.log(i) &#125;,1000 * i) &#125;)(i)&#125; 或者这样：for (var i = 0; i &lt; 5 ; i++) &#123; setTimeout((function foo(i) &#123; return function() &#123; console.log(i) &#125; &#125;)(i),1000 * i)&#125; 也可以使用 ES6 中的 let 换掉 var，使得 for 循环中 i 成为一个块级作用域的本地变量。 for (let i = 0; i &lt; 5 ; i++) &#123; setTimeout(function foo() &#123; console.log(i) &#125;,1000 * i)&#125; 闭包的优缺点闭包可以创建私有属性和方法。 var singel = (function () &#123; // 私有属性，外部访问不到 var age = 20 function foo() &#123; console.log('foo') &#125; return &#123; // 公有属性 name: 'Tom', getAge: function() &#123; return age &#125;, setAge: function(n) &#123; age = n &#125; &#125;&#125;)()console.log(singel.age) // undefinedsingel.foo() // Uncaught TypeError: singel.foo is not a functionconsole.log(singel.getAge()) // 20singel.setAge(10) console.log(singel.getAge()) // 10 单例：指的是只有一个实例的对象。JavaScript 一般以字面量的方式来创建单例。 匿名函数最大的用途就是创建闭包。并且还可以构建命名空间，减少全局变量的污染。 通过匿名函数实现一个闭包计数器：var numberCounter = (function() &#123; var num = 0 return function() &#123; return ++num &#125;&#125;)() 闭包的缺陷： 闭包所访问的自由变量会常驻内存增大内存的使用量，因此闭包滥用会造成网页性能问题。在老版本浏览器中由于垃圾回收有问题导致内存泄漏。正常使用闭包不会导致内存泄漏。 总结 作用域是定义变量的区域，规定了变量的访问范围，它在函数定义时确定。 执行上下文是一个对象，在函数执行时创建，它有变量对象、作用域链、this 三个属性。 函数执行时，变量对象通过函数的 arguments 属性初始化，它包含函数的参数、函数体里声明的变量。 函数执行时，作用域链是由函数的 [[scope]] 属性中的变量 + 活动对象中的变量组成的。 闭包是访问外部作用域的变量的函数。 闭包可以创建私有属性和方法。 闭包滥用会影响页面性能。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"集齐 JavaScript 中的继承方式","slug":"JavaScript中的继承","date":"2019-03-11T01:25:39.000Z","updated":"2019-05-14T01:24:03.635Z","comments":true,"path":"2019/03/11/JavaScript中的继承/","link":"","permalink":"inknight.cn/2019/03/11/JavaScript中的继承/","excerpt":"JavaScript 中的继承是以原型为基础的，所以首先要弄明白原型，在上一篇文章「JavaScript 中的原型原来是这样的」里应该会有所获。 继承是什么在传统面向对象语言( c++, c#, java… )中，继承是：使用已存在的类作为基础建立新的类的技术。我们把已存在的类称之为父类，新的类称之为子类。继承可以使得子类具有父类的各种属性和方法，因此可以避免写重复代码提高开发效率。","text":"JavaScript 中的继承是以原型为基础的，所以首先要弄明白原型，在上一篇文章「JavaScript 中的原型原来是这样的」里应该会有所获。 继承是什么在传统面向对象语言( c++, c#, java… )中，继承是：使用已存在的类作为基础建立新的类的技术。我们把已存在的类称之为父类，新的类称之为子类。继承可以使得子类具有父类的各种属性和方法，因此可以避免写重复代码提高开发效率。 而在 JavaScript 中是没有类这一概念的，但万物皆对象（除原始类型），我们用构造函数的原型对象代表父类对象，构造函数作为子类。通过构造函数创建出来的实例对象(子类实例)可以通过 __proto__ 访问到父类中的方法和属性，同样实现继承机制。 继承的方式 由于 JavaScript 的灵活，所以实现继承的方式也是有很多种的，我们先从简单的开始。 原型链继承 原型链继承顾名思义就是使用原型链实现继承，核心一句话：用父类的实例来充当子类的原型对象。 我们先看一段代码： function Animal(name) &#123; this.name = name // 动态类型模式 利用原型共享方法 if(this.eat !== 'function') &#123; Animal.prototype.eat = function() &#123; console.log('吃') &#125; &#125;&#125;function Dog(age) &#123; this.age = age&#125;// 用父类的实例来充当子类的原型对象Dog.prototype = new Animal('动物')var d = new Dog(3)console.log(d.age) // 3console.log(d.name) // '动物'd.eat() // '吃' 在浏览器控制台里： 画图分析一波： 但是在上面的例子里，我们不能在实例 Dog 子类时传递 name 参数的值。不能更改父类的 name 属性值。如果加一条 d.name = &#39;狗&#39;那么子类属性 name 会屏蔽父类属性 name ： 所以这种方式能够很好继承父类原型中的方法(方法一般不会去修改它)，但是不能很好继承父类的属性(属性修改会变成给子类实例赋新的属性值)。 总结缺点：子类在构建实例的时候不能向父类传递参数，导致不能很好的继承父类的属性。 借用构造函数继承 在子类构造函数中借用父类的构造方法(使用 call() 或 apply()) function Animal(name) &#123; this.name = name // 动态类型模式 利用原型共享方法 if(this.eat !== 'function') &#123; Animal.prototype.eat = function() &#123; console.log('吃') &#125; &#125;&#125;function Dog(name,age) &#123; // 借用父类的构造函数 Animal.call(this,name) /* 借用构造函数Animal 相当于执行了以下操作： this.name = name Animal.prototype.eat = function() &#123; console.log('吃') &#125; */ this.age = age&#125;var d = new Dog('哈士奇', 2)console.log(d.name) // '哈士奇'console.log(d.age) // 2d.eat() // Uncaught TypeError: d.eat is not a function 浏览器控制台中： 这种方式与上种方式恰好相反。子类不会继承父类原型中的任何属性和方法(即父类的原型不会被共享)，但是它可以在构建实例时向父类传参，将父类本身的属性带到子类实例本身上。 组合继承 原型链继承 + 借用构造函数继承双剑合璧，是 JavaScript 中最常用的继承方式。 function Animal(name) &#123; this.name = name // 动态类型模式 利用原型共享方法 if(this.eat !== 'function') &#123; Animal.prototype.eat = function() &#123; console.log('吃') &#125; &#125;&#125;function Dog(name,age) &#123; // 1.借用父类的构造函数 Animal.call(this,name) // 第一次调用 Animal this.age = age&#125;// 2.用父类实例充当子类原型Dog.prototype = new Animal('动物') // 第二次调用 AnimalDog.prototype.constructor = Dog // 手动指明构造函数var d = new Dog('哈士奇', 2)console.log(d.name) // '哈士奇'console.log(d.age) // 2d.eat() // '吃' 浏览器控制台中： 这种方法融合了上两种的优点，但还是有缺点的，由于调用了两次 Animal() 函数，导致对象 d 本身和原型上都有 name 属性，原型上的 name 属性是多余的，这样既浪费性能又浪费内存。 原型式继承 是 ES5 中 Object.creat() 的模拟实现，将传入的对象，作为新创建的对象的原型，并把这个对象返回。 function createObj(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;// 父类对象var animal = &#123; name:'动物',eat: function() &#123; console.log('吃') &#125;&#125;// 子类对象var dog = createObj(animal)// 等同于 var dog = Object.create(animal)dog.age = 1console.log(dog.name) // '动物'console.log(do.age) // 1dog.eat() // '吃' 浏览器控制台中： 这种方式和原型链继承的优缺点相同，不能向父类传递参数。 寄生式继承 利用原型式继承 + 工厂模式来封装子类创建的过程，在创建过程中增强了子类对象(添加了属性方法)。 function createDog(o,age) &#123; // Object.create(o) &lt;===&gt; createObj(o) 原型式继承 var dog = Object.create(o) dog.age = age dog.bark = function() &#123; console.log('┗|｀O′|┛ 嗷~~') &#125; return dog&#125;// 父类对象var animal = &#123; name:'动物',eat: function() &#123; console.log('吃') &#125;&#125;// 子类对象var dog = createDog(animal,2)console.log(dog.name) // '动物'console.log(dog.age) // 2dog.bark() // '┗|｀O′|┛ 嗷~~'dog.eat() // '吃' 浏览器控制台中： 这种方式，每次创建一次对象，就会创建一边 bark() 方法。 寄生组合式继承 借用构造函数继承 + 寄生式继承，这种方式是解决了组合继承的问题(调用了两次父类的构造函数)，它是最佳的继承方式。 function Animal(name) &#123; this.name = name // 动态类型模式 利用原型共享方法 if(this.eat !== 'function') &#123; Animal.prototype.eat = function() &#123; console.log('吃') &#125; &#125;&#125;function Dog(name,age) &#123; // 借用父类的构造函数 Animal.call(this,name) this.age = age&#125;/* 关键部分: 优化掉 new Animal()，间接的让 Dog.prototype 访问到 Animal.prototype */// 这里用 Object.create(原型, 构造器)取代寄生式继承 createDog(原型, 构造器)，写起来更简单。Dog.prototype = Object.create(Animal.prototype, &#123;constructor: &#123; value: Dog, enumerable: false, // 枚举时不可见 writable: true, // 可被赋值运算改变 configurable: true //可以被改变并且从对应对象中删除。 &#125;&#125;)var d = new Dog('哈士奇', 3)console.log(d.name) // '哈士奇'console.log(d.age) // '3'd.eat() // '吃' 浏览器控制台中： ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承和寄生式继承。这个方法接收两个参数:一个用作新对象原型的对象和一个可选的为新对象定义额外属性的对象。 这种方式高效体现在它只调用了一次 Animal 构造函数，因此舍弃了在 Animal 上多余的不需要的属性。 class 语法糖 在 JavaScript 中并没有类的概念，但在 ES6 中，我们可以使用 class 写出类似传统面向对象语言的类的声明和继承。但是本质上还是和以前没有多大区别，它只是一个语法糖，方便开发者书写。 构造函数 VS class 语法 class 继承class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log('吃') &#125;&#125;class Dog extends Animal &#123; constructor(name,age) &#123; // 相当于之前继承中的 Animal.call(this, name) super(name) this.age = age &#125; bark() &#123; console.log(this.name + '：嗷~~') &#125;&#125;var d = new Dog('哈士奇',3)console.log(d.name) // '哈士奇'console.log(d.age) // '3'd.eat() // '吃'd.bark() // '哈士奇：嗷~~' 浏览器控制台中： class 实现继承要注意两点： 使用 extends 声明继承哪个父类 在子类的构造函数中必须调用 super() 总结 继承是子类拥有父类的一些属性和方法，减少重复代码的书写 除了借用构造函数继承方式，其他继承方式都是基于原型的 class 是 ES6 中的语法糖，实现继承时要用 extends 声明继承的父类，子类构造函数中要写 super() 方法","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"JavaScript 中的原型原来是这样的","slug":"JavaScript中的原型","date":"2019-03-08T00:56:54.000Z","updated":"2019-05-14T01:23:35.087Z","comments":true,"path":"2019/03/08/JavaScript中的原型/","link":"","permalink":"inknight.cn/2019/03/08/JavaScript中的原型/","excerpt":"什么是原型 原型其实就是一个特殊的对象，在声明函数的时候自动创建的。","text":"什么是原型 原型其实就是一个特殊的对象，在声明函数的时候自动创建的。 比如，我们现在声明一个构造函数 A ，除了会申请保存函数的内存空间，还会额外申请一个内存空间，用于存储构造函数 A 的原型对象。所有函数中(Function.prototype.bind 除外)默认都有一个 prototype 的属性，它保存了函数的原型对象的地址(引用)(也就是它指向了原型对象)。而在原型对象中默认有一个 constructor 属性存储了构造函数的地址(引用)(也就是 constructor 指向了构造函数)。如果不理解上面所说的，那我们看下面的图： 浏览器控制台中： _ _proto_ _ 与 prototype 刚开始接触原型的时候这两个东西很容易就搞混了。 先记住以下两点，就很容易就区分了： prototype 是函数中才有的属性 __proto__ 是所有对象都有的属性 我们已经知道了函数中的 prototype 属性指向的是它的原型对象，那么对象中的 __proto__ 代表什么？ 一般情况下，对象中的 __proto__ 属性是指向它的构造函数的原型对象的，即和构造函数中的 prototype 属性所指向的对象是同一个对象。 用一段简单的代码：function A() &#123;&#125;var a = new A() 上图看着不够简便，我们简化一下： 还有一点，__proto__ 不是一个规范属性，ie(除了 ie10) 不支持。对应的标准属性是 [[Prototype]] ，但是这个属性我们没法直接访问到。开发者尽量不要用这种方式去访问，因为操作不慎会改变这个对象的继承原型链。 在使用 Object.create(参数) 方式创建对象时，对象的 __proto__ 属性指向的是传入的参数。 原型链 由于 __proto__ 是所有对象都具有的属性，而 __proto__ 本身指向的原型(函数.prototype)也是一个对象，它也有 __proto__ 属性。所以这样会形成由 __proto__ 将对象和原型连起来的链条。这就是原型链。原型链的顶端是 Object.prototype（Object 是所有对象的祖宗） ，Object.prototype.__proto__的值为 null 。 还是看之前的代码：function A() &#123;&#125;var a = new A() 它的原型链如下： 构造函数 A 其实也是一个对象。所有函数都是由 Function 函数构造的。(声明函数 function A() {} 等价于 var A = new Function()) 。所以所有函数的 __proto__ 指向的都是 Function.prototype 。更新上图： Function 也是一个函数，它的 __proto__ 指向的也是 Functon.prototype 即 Funtion.__proto__ === Function.prototype。继更新上图： Object 同样是一个函数，所以 Object.__proto__ === Function.prototype 到了这里，我们应该可以看懂下面这张图了： 原型的作用 当 JS 引擎查找对象属性时，先查找对象本身是否存在该属性，如果不存在，会在对象的 __proto__ 里找，还找不到就会沿着原型链一直找到原型链顶端(Object.prototype) 直到找到属性为止，最后在原型链顶端都没找到就返回 undefined 。 由于上面的机制，原型的作用就很明显了——共享属性，节省内存空间。 function Animal() &#123; this.name = '动物' this.eat = function() &#123; console.log('在吃···') &#125;&#125;var a1 = new Animal()var a2 = new Animal()console.log(a1.eat === a2.eat) // false// 每个对象的 eat 方法不是同一个，但方法类容一样，浪费内存 使用原型解决： function Animal(name) &#123; this.name = '动物'&#125;Animal.prototype.eat = function() &#123; console.log('吃')&#125;var a1 = new Animal()var a2 = new Animal()console.log(a1.eat === a2.eat) //true// a1.eat 和 a2.eat 都同是一个方法(Animal.prototype.eat) 原型非常适合封装共享的方法。但是上面的代码把构造函数和原型分开写了。封装不到位。使用动态类型模式解决。 function Animal() &#123; this.name = '动物' /* 判断 this.eat 是不是 函数类型， 如果不是，则表示是第一次创建对象或者调用 Animal 函数， 会将 eat 添加到原型中去。 如果是，则表示原型中存在了 eat 方法，不需要再添加。 */ if(typeof this.eat !== 'function') &#123; Animal.prototype.eat = function() &#123; console.log('吃') &#125; &#125;&#125;var a = new Animal()a.eat() 原型基于之前的共享属性和方法，是实现 JS 中继承的基础。 与原型有关的方法hasOwnProperty()通过之前的学习，我们知道了去访问一个对象的属性时，会在原型链上查找。所以我们并不知道这个属性来自哪里。 hasOwnProperty() 方法返回一个布尔值，可以判断一个属性名是否在自对象本身上。 function Animal() &#123;&#125;Animal.prototype.name = '动物'var a = new Animal()a.age = 3console.log(a.hasOwnProperty('name')) // falseconsole.log(a.hasOwnProperty('age') // true in 操作符 in 操作符用返回一个布尔值，用来判断一个属性名能否在对象上找到。在对象的原型链上找到也返回 true。 function Animal() &#123;&#125;Animal.prototype.name = '动物'var a = new Animal()a.age = 3console.log('name' in a) // trueconsole.log('age' in a) // trueconsole.log('sex' in a) // false 总结 原型就是一个对象，声明函数就会创建原型对象 prototype 只存在于函数中 所有对象都有一个 __proto__ 属性，它指向对象的构造函数的原型 原型也是对象，也有 __proto__ 属性，__proto__ 将对象和原型连接起来，形成原型链 Object.prototype 是原型链的顶端 访问对象的属性会沿着对象的原型链找下去 原型可以共享属性和方法，是继承的基础","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"JavaScript 中的数据类型类型和类型转换","slug":"JavaScript中的变量类型和类型转换","date":"2019-03-05T07:05:09.000Z","updated":"2019-05-15T01:19:50.671Z","comments":true,"path":"2019/03/05/JavaScript中的变量类型和类型转换/","link":"","permalink":"inknight.cn/2019/03/05/JavaScript中的变量类型和类型转换/","excerpt":"JavaScript 是一种弱类型或者说动态类型语言。所以你不用提前声明变量的类型，在程序运行时，类型会被自动确定，你也可以使用同一个变量保存不同类型的数据。","text":"JavaScript 是一种弱类型或者说动态类型语言。所以你不用提前声明变量的类型，在程序运行时，类型会被自动确定，你也可以使用同一个变量保存不同类型的数据。 数据类型原始类型在 JS 中一共 6 种原始类型： string number boolean undefined null symbol (ECMAScript 6) 对象类型 除了原始类型其他的都是对象类型（object）了。 内存空间 在 JS 中，每一个数据都需要存放在内存空间中。 原始类型数据直接存储在 栈内存(stack) 中，对象数据存储在 堆内存(heap) 中，并在 栈内存 中存放了该对象数据在 堆内存的地址(引用)。 var a1 = 0 // 栈var a2 = 'this is string' // 栈var a3 = null // 栈var b = &#123; m: 20 &#125; // 堆var c = [1,2,3] // 堆 上述变量的内存图解： 判断变量的类型 typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？ typeof typeof 运算符返回一个字符串，表示未经计算的操作数的类型。 对于原始类型，除了 null 类型都显示正确类型。 typeof '1' // 'string'typeof true // 'boolean'typeof 1 // 'number'typeof undefined // 'undefined'typeof Symbol() // 'symbol'typeof null // 'object' 这是一个 Bug typeof 1 === 'number' // truetypeof (typeof 1) === 'string' // true 对于对象来说，除了函数都会显示 object 。 typeof [] // 'object'typeof &#123;&#125; // 'object'typeof console.log // `function` instanceof instanceof 运算符返回一个布尔值，用于测试构造函数的 prototype 属性是否存在于对象原型链上。所以在判断对象的正确类型时可以考虑使用 instanceof 。 // 定义构造函数function A() &#123;&#125;function B() &#123;&#125;var a = new A()var b = new B()a instanceof A // true ，因为 Object.getPrototypeOf(a) === A.prototypea instanceof B // false ，B.prototype 不在 a 的原型链上 但是在浏览器环境下，我们的脚本可能要在多个窗口（不同 iframe）之间进行交互。多个窗口意味着多个全局环境，不同全局环境拥有不同的全局对象，从而拥有不同的内置构造函数。这会使得 instanceof 会出现一些问题。 var iframe = document.createElement('iframe') document.body.appendChild(iframe) xArray = window.frames[window.frames.length-1].Array var arr = new xArray(\"1\",\"2\",\"3\",\"4\",\"5\") //这个写法IE大哥下是不支持的，FF下才有 alert(arr instanceof Array) // false alert(arr.constructor === Array) // false Object.prototype.toString.call(变量) 可以正确判断 null ，Array ，其他的和 typeof 差不多 Object.prototype.toString.call([]) === '[object Array]' // trueObject.prototype.toString.call(&#123;&#125;) === '[object Object]' // trueObject.prototype.toString.call(Symbol()) === '[object Symbol]'// trueObject.prototype.toString.call(true) === '[object Boolean]'// truefunction Person() &#123;&#125;Object.prototype.toString.call(new Person()) // '[object Object]' 也有缺点，就是用户自定义的类型返回是 ‘[object Object]’ 类型转换 任意数据类型之间可以相互转换，但是 symbol 特殊。symbol 类型只能转换成 string 或 boolean 类型，其他的转换会报错。 强制转换Number() 原始类型 —&gt; 数字 // 1. 字符串 ---&gt; 数字 // 1) 可以被解析成数值的字符串 返回 数值 Number('123') // 123 // 2) 不能解析成数值的字符串 返回 NaN Number('123aaa') // NaN // 3) 空串 ---&gt; 0 Number('') // 0// 2. 布尔值 ---&gt; 数字 // 1) true ---&gt; 1 Number(true) // 1 // 2) false ---&gt; 0 Number(false) // 0// 3. undefined ---&gt; NaN Number(undefined) // NaN // 4. null ---&gt; 0Number(null) // 0 全局函数 parseInt() 和 parseFloat() 可以将一些字符串转换成数字,但没 Number() 严格 。把其他原始类型都会转换成 NaN 。 parseInt('123aaa') // 123parseFloat('1.23aaa') // 1.23parseInt(true) // NaN 对象 —&gt; 数字 Number() 方法的参数是对象时，一般情况下，除非是包含单个数字的数组会返回数字，否则返回 NaN 。Number(&#123;a: 1&#125;) // NaNNumber([1,2]) // NaNNumber([1]) // 1 在执行 Number(对象) 方法时，会先进行参数处理，将对象转换成原始类型，再进行转换成数字的操作。 第一步，调用对象自身的 valueOf() 方法（ var a = new String(123); a.valueOf() –&gt; ‘123’ ）。如果返回的值是原始类型，则直接将该值转换成数字并返回。不再进行后续步骤。 第二步，如果 valueOf() 方法返回的是对象，则调用原对象自身的 toString() 方法，如果此时返回的值是原始类型，则将该值转换成数字并返回，不再进行后续操作。 如果 toString() 方法返回的还是对象，就报错。 Number(&#123;a: 1&#125;) // NaN// 过程如下：var t = &#123;a: 1&#125;// 第一步t.valueOf() // &#123;a: 1&#125;// 第二步t.toString() // '[object Object]'Number('[object Object]') // NaN Number([1,2])//过程如下：// 第一步[1,2].valueOf() // [1,2]// 第二步[1].toString() // '1,2'Number('1,2') // NaN // 再来看看参数是单个数字的数组时的情况 Number([1]) // 1 //过程如下：// 第一步[1].valueOf() // [1]// 第二步[1].toString() // '1'Number('1') // 1 String() String() 函数可以将任意类型的值转换成字符串。 原始类型 —&gt; 字符串 var a = Symbol(&#123;&#125;)String(a) // 'Symbol([object Object])'String(Symbol([])) // 'Symbol()' 对象 —&gt; 字符串数组会返回该数组的字符串形式，函数返回完整函数的字符串，其他的返回一个类型字符串。 String([1,2]) // '1,2'String([]) // ''function foo(x)&#123; return x*x &#125;String(foo) // 'function foo(x)&#123; return x*x &#125;'String(&#123;a: 1&#125;) // '[object Object]'[1,2,3].toString() // '1,2,3'Object.prototype.toString.call([1,2,3]) // '[object Array]' String(对象) 方法的转换规则与 Number(对象) 基本相同，只是互换了 valueOf() 与 toString() 的执行顺序。 先调用对象的 toString() 方法。如果返回的值是原始类型，则将该值转换成字符串并返回。不再执行以下步骤。 如果 toString() 返回的是对象，则调用原对象的 valueOf() 方法。如果返回的值是原始类型，将该值转换成字符串并返回。不再执行后续操作。 如果 valueOf() 方法返回的还是对象，就报错。 自定义对象的 toString() 方法和 valueOf() 方法：var obj = &#123; valueOf: function() &#123; return 1 &#125;, toString: function() &#123; return 2 &#125;&#125;String(obj) // '2'Number(obj) // 1 Boolean() Boolean() 函数可以将任意类型转换成布尔值除了以下五个值转换结果为 false ，其他值全部转换为 true undefined null &#39;&#39; (空字符串) -0 或 0 NaN !!数据 与 Boolean(数据) 效果一样。 Boolean(undefined) // falseBoolean(null) // falseBoolean('') // falseBoolean(0) // falseBoolean(NaN) // false! NaN // true!! NaN // false 自动转换 自动转换就是没有显式地使用函数对数据进行类型转换。但它是以强制转换为基础的。 当预期数值与实际数值不匹配时，JavaScript 就会自动调用预期类型的转换函数对实际值进行转换。 进行算术运算 运算子都是原始类型 在加法运算中 只要一方时字符串，另一方就会转换成字符串。这是字符串拼接。 其他 - * / ** % ++ -- +(一元运算符 表示正数) -(一元运算符 表负数) 都会将运算子转换成数字。1 + '1' // '11'2 * '3' // 61 - 'a' // NaN 3 + - '1' // 2 运算子是对象 会先把对象转换成原始类型再按预期值转换。具体方法是：先调用对象的 valueOf() 方法试图将对象转换成原始类型，如果返回的是对象，就再调用原对象的 toString() 方法，如果返回的还是对象就报错。 var obj = &#123; valueOf: function() &#123; return '1' &#125;, toString: function() &#123; return '10' &#125;&#125;10 - obj // 91 + [1,2] // '11,2'// [1,2].toString() ---&gt; '1,2' 进行比较运算 === 和 !== 不会发生类型转换，只要类型不同就返回 false. 两边同时为字符串会比较 Unicode 码，否则都会转换成数字进行比较(null、undefined 除外)。 NaN 与任意值(包括本身NaN)比较都返回 false null undefined 除了 null(undefined) == undefined(null) 返回 true，其他 &gt; &lt; == 有 null 或 undefined 参与的都返回 false 。'abc' &gt; 'abd' // falsetrue &gt; false // true ---&gt; Number(true) &gt; Number(false)true &gt; '-1' // true ---&gt; Number(true) &gt; Number('-1')var obj = &#123;valueOf: function() &#123;return '1'&#125;&#125;[3] &gt; obj // true// 过程如下：// Number([3]) &gt; Number(obj)// Number('3') &gt; Number('1')// 3 &gt; 10 == null // false == 常用于判断函数的参数是否等于 null 或者 undefined ，因为 null == undefinded 返回 true function fun(x) &#123; if(x == null) &#123;···&#125;&#125; 逻辑运算 !参数 参数&amp;&amp; 参数|| 参数? :(三元运算符) if(参数) 都会将非布尔的参数转换成布尔类型(使用 Boolean(参数) 函数)。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"网络协议总结","slug":"网络协议","date":"2019-03-03T01:38:53.000Z","updated":"2019-05-23T02:33:38.252Z","comments":true,"path":"2019/03/03/网络协议/","link":"","permalink":"inknight.cn/2019/03/03/网络协议/","excerpt":"前端主要关注于应用层 HTTP 协议，传输层 TCP 协议,断舍离一下，就主要总结这两种协议了。","text":"前端主要关注于应用层 HTTP 协议，传输层 TCP 协议,断舍离一下，就主要总结这两种协议了。 前端主要关注于应用层的 HTTP 协议，传输层的 TCP 协议,断舍离一下，就主要总结这两种协议了。 OSI 参考模型 与 TCP/IP 五层模型 我们主要关注于 TCP/IP 五层模型 的 应用层 和 传输层 就足够了。 应用层: 作用：为应用程序提供服务。 常见协议：HTTP、HTTPS、FTP、POP3、SMTP等。 传输层: 作用：实现应用程序之间的数据传输。 协议：UDP、TCP UDP 与 TCPUDP UDP 是面向无连接的协议，它只会把数据传递给接收端，但不会关注接收端是否已经正确接收了数据，所以有时候 UDP 会被认为是不可靠的数据报协议。但这种特性反而适合多播，实时的视频和音频传输。 优点： 无需建立连接（减少了延迟） 实现简单（效率高） 头部开销小（ 8 字节） 没有拥塞控制（更好的控制发送时间和速率） 缺点： 没有建立连接（数据想发就发，不可靠） 没有拥塞控制（网络条件不好时会导致丢包） TCP TCP 是面向有连接的协议，在使用 TCP 协议 传输数据之前一定需要在发送方和接收方之间建立连接。建立连接三次握手，断开连接四次挥手~ TCP 建立连接三次握手 第一次握手： 客户端向服务端发送一个 SYN（Seq=X） 包，客户端进入 SYN-SENT 状态，等待服务端的 ACK（Ack=X+1）回复。ps: Seq 是序号，Ack 是确认序号。 第二次握手： 服务端根据接收到客户端发来的 SYN（Seq=X） 包后返回一个 ACK（Ack=X+1） 以及 SYN（Seq=Y） 包给客户端，服务端进入 SYN-RECIVED 状态，等待客户端的 ACK（Ack=Y+1） 回复。 第三次握手： 客户端接收到 ACK（X+1） 后，进入 ESTABLISHED 状态。根据服务端发来的 SYN（Y） 返回一个 ACK（Y+1） 包给服务端。服务端 接收 ACK（Y+1）后进入 ESTABLISHED 状态。此时连接建立成功。 这个过程可以用以下三句形象表示： (客户端)：我想建立连接了，服务端你能听到吗？ (服务端)：我听得到，你这边听得到吗？ (客户端)：我也听得到。 TCP 关闭连接四次挥手 这个过程可以用以下四句句形象表示： (客户端)：我想关闭连接了，你工作完了吗？ (服务端)：我知道了，等等。 (服务端)：我现在准备关闭连接了，ok 吗？ (客户端)：ok，你关闭吧。 UDP 与 TCP 的区别 UDP 协议是面向无连接的，它不能保证数据有序且不丢失的传到对端，但是 UDP 比 TCP 更高效。 TCP 协议是面向有连接的，建立和断开连接都需要握手，在传输数据的过程中，通过滑动窗口（流量控制）、拥塞处理（慢开始，拥塞避免，快速重传，快速恢复），能够正确处理丢包问题，保证接收方能够收到数据，与此同时还能够有效利用网络带宽。 HTTP HTTP (HyperText Transfer Protocol) 超文本传输协议 是一个基于 TCP (传输层) 的应用层协议，是客户端与服务端之间请求和响应的标准。 主要特点 简单快速 客户端向服务器请求服务时，只需请求方法和请求路径。 无状态 客户端再次向服务器请求服务时，服务器并不知道客户端之前是否请求过。 无连接 每次请求都会建立一个 TCP 连接，请求处理完成后连接断开。 HTTP 报文 请求行： GET https://www.baidu.com/ HTTP/1.1 由请求方法、URL、协议版本组成 响应行： HTTP/1.1 200 OK协议版本、状态码、状态信息组成 HTTP 请求方法请求方法分为很多种，最常用的也就是 GET 和 POST 了。虽然请求方法很多，但更多的是为了传达语义。更多的方法的语义描述可以阅读 文档 。 GET 和 POST 的区别 GET 能缓存、请求长度限制、 有历史记录 GET 多用于 无副作用(不修改资源)、幂等(请求次数与资源无关)的场景。 POST POST 相对 GET 安全一点点，因为 GET 请求发送的数据包含在 URL 里。 两者详细对比： 状态码 状态码表示了响应的状态，可以让我们知道这一次的请求是成功还是失败，如果失败，是什么原因导致的。 2XX 成功 200 OK ，请求成功并返回数据 204 No Content ，成功但无内容 206 Partial Content ,范围请求 3XX 重定向 301 永久重定向，表示资源已被分配了新的 URL 302 临时重定向，资源临时被分配新的 URL 304 资源未修改，可使用缓存 4XX 客户端错误 400 请求语法错误 401 要求身份认证 403 请求被服务器拒绝 404 资源不存在 5XX 服务器错误 500 服务器错误 503 服务器超负载或停机维护 HTTPS 更安全的网络传输协议 需要安装证书（公钥） 经过 SSL/TLS 协议 加密，传输的内容是经过加密的 使用 443 端口 HTTP/2 多路复用 在同一个 TCP 连接上传输所有的请求数据，避免 队头阻塞(浏览器限制同一个域名下的连接数)问题 Header 压缩 使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，避免 header 重复传输。 二进制传输 在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。 服务端推送 服务端可以在客户端的某个请求后，主动推送其他客户端在之后会用到的资源。省去了客户端重复请求的步骤，降低了延迟。 在浏览器输入 url 后会发生什么 浏览器会通过 url 拿到域名。 通过这个域名想拿到对应的服务器的 ip 地址 先在浏览器缓存中找 没找到就到操作系统缓存里找 在 host 文件找 向 DNS 服务器发起请求，拿到对应的 ip 地址 本地随机开个没占用的端口通过拿到的 ip 地址及 url 中的端口号与服务器建立 TCP 连接 浏览器通过这个连接通道向服务器发送 http 请求 服务器处理请求并返回 HTTP 响应报文 浏览器解析渲染页面 断开 TCP 连接","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"计算机网络","slug":"计算机网络","permalink":"inknight.cn/tags/计算机网络/"}]},{"title":"DOM 事件详解","slug":"DOM-事件总结","date":"2019-01-23T14:13:32.000Z","updated":"2019-03-30T00:50:37.143Z","comments":true,"path":"2019/01/23/DOM-事件总结/","link":"","permalink":"inknight.cn/2019/01/23/DOM-事件总结/","excerpt":"事件是 JavaScript 与 HTML 交互的基础。要实现用户与页面的交互，先要对目标元素绑定特定的事件、设置事件处理函数，然后用户触发事件，事件处理函数执行，产生交互效果。","text":"事件是 JavaScript 与 HTML 交互的基础。要实现用户与页面的交互，先要对目标元素绑定特定的事件、设置事件处理函数，然后用户触发事件，事件处理函数执行，产生交互效果。 DOM 事件级别DOM 级别分为四个级别：DOM0 级、DOM1 级、DOM2 级、DOM3 级；DOM 事件级别分为三个级别： DOM0 级事件 &lt;button id=\"btn\" type=\"button\"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn') btn.onclick = function() &#123; console.log('Hello World') &#125; // btn.onclick = null // 解绑事件&lt;/script&gt; 缺点：无法设置多个事件处理函数 DOM2 级事件 &lt;button id=\"btn\" type=\"button\"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); btn.addEventListener('click', showFn, false) btn.addEventListener('click', showFn2, false) // btn.removeEventListener('click', showFn, false) // 解绑事件 function showFn() &#123; alert('Hello World'); &#125; function showFn2() &#123; alert('Hello World2'); &#125; &lt;/script&gt; 可以为事件设置多个事件处理函数，可以通过第三个参数 ( useCapture ) 设置在什么阶段执行事件处理函数，默认是 false， 即在事件冒泡阶段执行事件处理函数。 需要注意的是在 IE8 及以下版本需要用 attachEvent 和 detachEvent 实现，只有两个参数，事件名需要以 on 开头，只支持在事件冒泡阶段执行事件处理函数。 DOM3 级事件 DOM3 级事件是在 DOM2 级事件的基础上添加了更多的事件类型，允许自定义事件。 UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified // 自定义事件var event = new Event('test')// 给元素绑定事件domElement.addEventListener('test', function() &#123; console.log('event test')&#125;,)// 触发事件setTimeout(function() &#123; domElement.dispatchEvent(event)&#125;, 1000) DOM 事件流 想象画在一张纸上的一组同心圆。如果把手指放在圆心上，那么手指指向的不仅仅是一个圆，而是纸上的所有圆。所以如果点击了某个按钮，点击事件不仅仅发生在这个按钮上，整个页面也被点击了。 事件流又称为事件传播，描述的是从页面中接收事件的顺序。DOM2 级事件规定事件流包括三个阶段: 事件捕获(capturing phase)、目标事件(target phase)、事件冒泡(bubbling phase)。发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段 事件冒泡 事件开始时由最具体的元素(目标元素)接收，然后逐级向上传播。 &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: green; &#125; #child &#123; width: 100px; height: 100px; background-color: yellow; &#125;&lt;/style&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;目标元素&lt;/div&gt; 父级元素&lt;/div&gt;&lt;script&gt; var parent = document.getElementById('parent') var child = document.getElementById('child') parent.addEventListener('click', function(e) &#123; console.log('parent bubbling') &#125;, false) child.addEventListener('click', function() &#123; console.log('target bubbling') &#125;, false) document.body.addEventListener('click', function() &#123; console.log('body bubbling') &#125;, false) document.documentElement.addEventListener('click', function() &#123; console.log('html bubbling') &#125;, false) document.addEventListener('click', function() &#123; console.log('document bubbling') &#125;, false) window.addEventListener('click', function() &#123; console.log('window bubbling') &#125;, false)&lt;/script&gt; 运行结果： 事件捕获 事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。 &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: green; &#125; #child &#123; width: 100px; height: 100px; background-color: yellow; &#125;&lt;/style&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;目标元素&lt;/div&gt; 父级元素&lt;/div&gt;&lt;script&gt; var parent = document.getElementById('parent') var child = document.getElementById('child') parent.addEventListener('click', function(e) &#123; console.log('parent capture') &#125;, true) child.addEventListener('click', function() &#123; console.log('target capture') &#125;, true) document.body.addEventListener('click', function() &#123; console.log('body capture') &#125;, true) document.documentElement.addEventListener('click', function() &#123; console.log('html capture') &#125;, true) document.addEventListener('click', function() &#123; console.log('document capture') &#125;, true) window.addEventListener('click', function() &#123; console.log('window capture') &#125;, true)&lt;/script&gt; 运行结果： 事件对象参数 event 在用户触发事件，执行事件处理函数的时候，默认会向事件处理函数传入一个 event 对象，它记录了该事件的状态和行为。 event 常用属性和方法 type 事件类型 target 事件发出者(触发事件的元素) currentTarget 事件监听者(被绑定事件的元素) stopPropagation() 阻止事件冒泡或捕获 preventDefault() 阻止浏览器默认行为 target 、currentTarget 与 this&lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var parent = document.getElementById('parent') function handler(e) &#123; console.log(e.target) console.log(e.currentTarget) console.log(this) &#125; // 给父盒子注册点击事件 parent.addEventListener('click', handler, false)&lt;/script&gt; 当点击 parent 时，输出： 1 &lt;div id=\"parent\"&gt;...&lt;/div&gt;2 &lt;div id=\"parent\"&gt;...&lt;/div&gt;3 &lt;div id=\"parent\"&gt;...&lt;/div&gt; 当点击 child 时，输出： 1 &lt;div id=\"child\"&gt;...&lt;/div&gt;2 &lt;div id=\"parent\"&gt;...&lt;/div&gt;3 &lt;div id=\"parent\"&gt;...&lt;/div&gt; 所以 target 是事件发出者，curentTarget 是事件监听者，事件处理函数中的 this 等同于 e.currentTarget event 对象的一些兼容性写法 获得 event // 事件处理函数function handleClick(event) &#123; var e = event || window.event ···&#125; 获得 target ···var target = e.target || e.srcElement··· 阻止浏览器默认行为 ···e.preventDefault ? e.preventDefault() : (e.returnValue = false)··· 阻止冒泡 ···e.stopPropagation ? e.stopPropagation() : (e.cancelBubble = true)··· 事件绑定与解绑 function addEvent(element, type, fn) &#123; element.addEventListener ? element.addEventListener(type, fn, false) : element.attachEvent('on'+ type, fn)&#125;function removeEvent(element, type, fn) &#123; element.removeEventListener ? element.removeEventListener(type, fn, false) : element.detachEvent('on'+ type, fn)&#125; 属性表 基础属性 属性 描述 altKey 返回当事件被触发时，”ALT” 是否被按下。 button 返回当事件被触发时，哪个鼠标按钮被点击。 clientX 返回当事件被触发时，鼠标指针的水平坐标。 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 ctrlKey 返回当事件被触发时，”CTRL” 键是否被按下。 metaKey 返回当事件被触发时，”meta” 键是否被按下。 relatedTarget 返回与事件的目标节点相关的节点。 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 shiftKey 返回当事件被触发时，”SHIFT” 键是否被按下。 IE 属性 属性 描述 cancelBubble 如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。 fromElement 对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。 keyCode 对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup offsetX,offsetY 发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。 returnValue 如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 false 可以阻止浏览器默认行为 srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。 toElement 对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。 x,y 事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。 标准 event 属性（2级 DOM 事件标准定义的属性） 属性或方法 描述 bubbles 返回布尔值，指示事件是否是冒泡事件类型。 cancelable 返回布尔值，指示事件是否可拥可取消的默认动作。 currentTarget 返回其事件监听器触发该事件的元素。 eventPhase 返回事件传播的当前阶段。 target 返回触发此事件的元素（事件的目标节点）。 timeStamp 返回事件生成的日期和时间。 type 返回当前 Event 对象表示的事件的名称。 initEvent() 初始化新创建的 Event 对象的属性。 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 stopPropagation() 不再派发事件（常用于阻止事件冒泡）。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"inknight.cn/tags/HTML/"},{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"CSS盒模型分析","slug":"CSS盒模型分析","date":"2019-01-22T12:15:38.000Z","updated":"2019-03-30T00:50:38.271Z","comments":true,"path":"2019/01/22/CSS盒模型分析/","link":"","permalink":"inknight.cn/2019/01/22/CSS盒模型分析/","excerpt":"CSS 盒模型是前端学习中的基础，总结一下~","text":"CSS 盒模型是前端学习中的基础，总结一下~ 基本概念页面中的每个元素都可以看成一个盒子，盒子里面可以装其他盒子，层层嵌套。html 标签就是最外面的大盒子。每个盒子由内向外分别是 content, padding, border, margin 。 分类盒模型有两种，标准盒模型 和 IE盒模型 。主要区别是它们的 width 和 height 不同 标准盒模型 盒子宽高是 content(内容) 的宽高 IE盒模型 盒子宽高是 border + padding + content 的宽高 浏览器默认使用标准盒模型，在 ie8+ 中 可以通过设置 box-sizing 样式属性改变盒模型box-sizing: content-box —&gt; 标准盒模型（默认） border-box —&gt; IE 盒模型通过 js 获取盒子宽高 以下 domElement 是表示 HTML 元素的伪代码 domElement.style.width/height 只能获取内联样式中的宽高 domElement.currentStyle.width/height 获取的是浏览中渲染完成后元素的宽高，只有 IE 浏览器支持 window.getComputedStyle(domElement).width/height 和方式2一样，但可以兼容更多浏览器 domElement.offsetWidth/offsetHeight 不管使用的什么盒模型，获取的都是 IE盒模型 的宽高 外边距折叠问题 相邻元素在竖直方向上的外边距在相遇时会发生合并，合并后的外边距的高度等于两个外边距中较大的那个值。 兄弟元素间 父子元素间 外边距折叠解决方案（BFC） Block Formatting Context （块级格式化上下文） BFC 可以简单地理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC。 怎样让元素创建 BFC float 的值不为 none （浮动元素） overflow 的值不为 visible display 的值为 inline-block 、table-caption 、 table-cell 、flex 、inline-flex positon 的值为 absolute 或 fixed &lt;html&gt;(根元素) BFC 的布局规则 内部的 box 会在垂直方向上一个接一个地放置 （平时说的块级元素一行行放） box 间垂直方向的距离由 margin 决定 。同一个BFC中的两个相邻的 box 还是会产生外边距重叠问题 BFC 的区域不会与 浮动的 box 重叠 BFC 是一个独立的容器，里面的元素不会影响外面的元素，反之亦然。 包含浮动元素，计算 BFC 的高度时，浮动的元素也会参与计算 BFC 的应用场景 分属于不同 BFC 的元素可以防止垂直外边距折叠 清除内部浮动（使浮动元素可以撑起父盒子） 自适应两栏布局（BFC 区域不会与浮动元素重叠） 防止元素被浮动元素覆盖 float + BFC 两栏布局:&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left &#123; float: left; width: 100px; background-color: blue; &#125; .right &#123; overflow: hidden; /* 触发 BFC */ background-color: green; &#125;&lt;/style&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"inknight.cn/tags/HTML/"},{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"}]},{"title":"初识Three.js","slug":"初识Three-js","date":"2018-12-28T14:08:15.000Z","updated":"2019-03-30T00:50:25.307Z","comments":true,"path":"2018/12/28/初识Three-js/","link":"","permalink":"inknight.cn/2018/12/28/初识Three-js/","excerpt":"什么是 Three.js ? 简单来看, Three 是 3D 的意思, js 是 JavaScript , 也就是用 JavaScript 开发 3D 的应用程序。","text":"什么是 Three.js ? 简单来看, Three 是 3D 的意思, js 是 JavaScript , 也就是用 JavaScript 开发 3D 的应用程序。 HelloWorld···&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; HelloWorld &lt;/title&gt; &lt;!-- 0. 引入three.js 文件 --&gt; &lt;script src=\"./js/three.js\" &gt;&lt;/script&gt;&lt;/head&gt;··· // 1. 创建场景var scene = new THREE.Scene()// 2. 创建相机var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000)camera.position.z = 5 //设置相机位置// 3. 创建并设置渲染器var renderer = new THREE.WebGLRenderer(&#123;antialias: true&#125;)renderer.setSize(window.innerWidth, window.innerHeight)document.body.appendChild(renderer.domElement)// 4. 创建网格模型添加到场景中var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 1), new THREE.MeshBasicMaterial(&#123;color: 0x00ffff&#125;))scene.add(cube)// 5. 渲染// 设置一个动画函数var animate = function () &#123; // 在浏览器下次重绘前执行回调函数 回调的次数通常是每秒60次 也就是常说的FPS 是60 requestAnimationFrame(animate) // 模型旋转 cube.rotation.x += 0.01 cube.rotation.y += 0.01 //渲染摄像机看见的场景 renderer.render(scene, camera)&#125;animate() 渲染结果： 必要的三个组件场景创建场景： var scene = new THREE.Scene() 场景是所有物体的容器。 相机创建相机： var camera = new THREE.PerspectiveCamera(视口角度, width/height, 视野最近距离, 视野最远距离) 相机就像人的眼睛。 渲染器 创建渲染器： var renderer = new THREE.WebGLRenderer() 设置渲染区域尺寸： renderer.setSize(width, height) 画布添加到页面中： documment.body.appendChild(render.domElement) 渲染器就像视觉神经，缺少它，我们什么也看不见。 坐标系三维坐标系分为两种： 左手坐标系 右手坐标系 在 There.js 中采用的是右手坐标系。 物体旋转的方向 mesh.rotation.y += 0.1 正方向是四指指向的方向","categories":[{"name":"Three.js","slug":"Three-js","permalink":"inknight.cn/categories/Three-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"},{"name":"WebGL","slug":"WebGL","permalink":"inknight.cn/tags/WebGL/"}]},{"title":"HTML笔记","slug":"HTML笔记","date":"2018-10-02T09:48:20.000Z","updated":"2019-03-30T00:50:34.501Z","comments":true,"path":"2018/10/02/HTML笔记/","link":"","permalink":"inknight.cn/2018/10/02/HTML笔记/","excerpt":"HTML初识","text":"HTML初识 Hyper Text Markup Language（超文本标记语言） 用标签来描述网页的结构内容HTML语法骨架： &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;!-- 还可以插入其他meta、样式单等信息 --&gt;&lt;/head&gt;&lt;body&gt;页面内容部分&lt;/body&gt;&lt;/html&gt;&lt;!-- 注意：不要在&lt;html&gt;和&lt;head&gt;之间插入任何内容 &lt;/head&gt;和&lt;body&gt; &lt;/body&gt;和&lt;/html&gt; 之间插入内容--&gt; HTML 标签HTML 元素&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;a href=\"#\"&gt;This is a link&lt;/a&gt;&lt;br /&gt; 开始标签 元素内容 结束标签 &lt;p&gt; This is a paragraph &lt;/p&gt; &lt;a href=&quot;#&quot;&gt; This is a link &lt;/a&gt; &lt;br /&gt; HTML 元素指的是从开始标签到结束标签的所有代码 HTML 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数HTML元素可拥有属性 排版标签 标题标签 &lt;h1&gt;&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h3&gt;&lt;/h3&gt; &lt;h4&gt;&lt;/h4&gt; &lt;h5&gt;&lt;/h5&gt; &lt;h6&gt;&lt;/h6&gt; 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。一般h1都是给logo使用，或者页面中最重要标题信息。 段落标签 &lt;p&gt;文本内容&lt;/p&gt; 水平线标签（horizontal） &lt;hr /&gt; &lt;!-- 在html5里可以写成&lt;hr&gt; 单标签(空元素)可以省略结束标签--&gt; 换行标签（break） &lt;br /&gt; 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 div span标签 &lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; &lt;!-- 不在同一行 --&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt; &lt;!-- 在同一行 --&gt; &lt;div&gt;元素是块级元素，它是可用于组合其他 HTML 元素的容器。&lt;div&gt;元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。&lt;span&gt;元素是内联元素，可用作文本的容器&lt;span&gt;元素也没有特定含义。内联元素在显示时通常不会以新行开始。 文本格式化标签 标签 作用 &lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt; 粗体 &lt;i&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; 斜体 &lt;s&gt;&lt;/s&gt; &lt;del&gt;&lt;/del&gt; 删除线 &lt;u&gt;&lt;/u&gt; &lt;ins&gt;&lt;/ins&gt; 下划线 strong em del ins 语义更强烈 图像标签&lt;img src=\"图像的URL\" alt=\"图像不能显示时的替换文字\" title=\"鼠标悬停的显示内容\" width=\"\" height=\"\" border=\"\"/&gt; 链接标签&lt;a href=\"跳转目标\" target=\"定义被链接的文档在何处显示\"&gt;文本或图片&lt;/a&gt; 锚点定位 1.使用&lt;a href=&quot;#(id名)&quot;&gt;链接&lt;/a&gt;创建一个链接。&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;2.使用相应的id名标注跳转的目标位置。&lt;h3 id=&quot;two&quot;&gt;第二集&lt;/h3&gt; 将 # id名添加到URL的末端，就可以直接跳转到指定页面的指定位置。 base 标签···&lt;head&gt;···&lt;base target=\"_blank\" /&gt;&lt;base href=\"http://www.w3school.com.cn\" /&gt;···&lt;/head&gt;··· &lt;base&gt;标签为页面上所有链接规定默认地址或目标 标签必须位于 head 元素内部 列表标签 无序列表 &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; ···&lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; ···&lt;/ol&gt; 自定义列表 &lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ··· &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ··· ···&lt;/dl&gt; 表格标签&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;td&gt; ··· &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; ··· &lt;/tr&gt; ···&lt;/table&gt; 表格属性 属性名 含义 默认值 border 表格边框 0px cellspacing 单元格与单元格边框之间的距离 2px cellpadding 单元格内容与边框的距离 1px width 表格宽度 height 表格高度 align 表格在网页水平对齐方式 left(/center/right) 表头标签 表头单元格一般位于表格的第一行或第一列，其文本默认加粗居中。用&lt;th&gt;&lt;/th&gt;替换&lt;td&gt;&lt;/td&gt;即可将普通单元格换成表头单元格 表格结构&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; ··· &lt;/tr&gt; ··· &lt;/tbody&gt;&lt;/table&gt; 合并单元格 跨行合并：rowspan 跨列合并：colspan 1.先确定是跨行还是跨列 2.根据先上后下，先左后右找到目标单元格 3.合并后删除多余单元格 表单标签一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件： 包含了具体的表单功能项，如单行文本输入框、密码输入框、单选框、复选框、提交按钮、重置按钮等。 提示信息：给用户看的信息 表单域：一个容纳表单信息和表单控件的容器，可以定义处理表单数据所用程序的URL地址，以及数据提交到服务器的方法。没有表单域，表单中的数据就无法送达到服务器。 表单域&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单名称\"&gt;&lt;!-- 各种表单控件 --&gt;&lt;/form&gt; input标签属性： label标签&lt;form&gt; &lt;label for=\"male\"&gt;Male&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"male\" /&gt; &lt;br /&gt; &lt;label for=\"female\"&gt;Female&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"female\" /&gt;&lt;/form&gt; 作用：在label元素里点击后会触发此控件，让浏览器将焦点转到label中for绑定的id的表单控件上 textarea标签（文本域）&lt;textarea cols=\"每行中的字符数\" row=\"显示的行数\"&gt;文本内容&lt;textarea&gt; select标签（下拉菜单）&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ···&lt;/select&gt; 1.select元素中至少应包含一个&lt;option&gt;&lt;/option&gt; 2.在option 中定义select=”selected”属性时，当前选项为默认值。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"inknight.cn/tags/HTML/"}]}]}