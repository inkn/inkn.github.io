{"meta":{"title":"墨夜","subtitle":null,"description":null,"author":"inkn","url":"inknight.cn"},"pages":[{"title":"about","date":"2018-12-29T13:15:42.000Z","updated":"2018-12-29T13:21:17.235Z","comments":true,"path":"about/index.html","permalink":"inknight.cn/about/index.html","excerpt":"","text":"正在学前端的菜鸟💦"},{"title":"categories","date":"2018-12-29T13:33:05.000Z","updated":"2018-12-31T14:19:57.307Z","comments":true,"path":"categories/index.html","permalink":"inknight.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-29T13:32:12.000Z","updated":"2018-12-31T14:20:02.378Z","comments":true,"path":"tags/index.html","permalink":"inknight.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 中的变量类型和类型转换","slug":"JavaScript-中的变量类型和类型转换","date":"2019-03-05T07:05:09.000Z","updated":"2019-03-06T04:19:45.687Z","comments":true,"path":"2019/03/05/JavaScript-中的变量类型和类型转换/","link":"","permalink":"inknight.cn/2019/03/05/JavaScript-中的变量类型和类型转换/","excerpt":"JavaScript 是一种弱类型或者说动态类型语言。这意味着你不用提前声明变量的类型，在程序运行时，类型会被自动确定，你也可以使用同一个变量保存不同类型的数据。","text":"JavaScript 是一种弱类型或者说动态类型语言。这意味着你不用提前声明变量的类型，在程序运行时，类型会被自动确定，你也可以使用同一个变量保存不同类型的数据。 数据类型原始类型在 JS 中一共 6 种原始类型： string number boolean undefined null symbol (ECMAScript 6) 对象类型 除了原始类型其他的都是对象类型（object）了。 内存空间 在 JS 中，每一个数据都需要存放在内存空间中。 原始类型数据直接存储在 栈内存(stack) 中，对象数据存储在 堆内存(heap) 中，并在 栈内存 中存放了该对象数据在 堆内存的地址(引用)。 var a1 = 0 // 栈var a2 = 'this is string' // 栈var a3 = null // 栈var b = &#123; m: 20 &#125; // 堆var c = [1,2,3] // 堆 上述变量的内存图解： typeof 与 instanceof typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？ typeof typeof 运算符返回一个字符串，表示未经计算的操作数的类型。 对于原始类型，除了 null 类型都显示正确类型。 typeof '1' // 'string'typeof true // 'boolean'typeof 1 // 'number'typeof undefined // 'undefined'typeof Symbol() // 'symbol'typeof null // 'object' 这是一个 Bug typeof 1 === 'number' // truetypeof (typeof 1) === 'string' // true 对于对象来说，除了函数都会显示 object 。 typeof [] // 'object'typeof &#123;&#125; // 'object'typeof console.log // `function` instanceof instanceof 运算符返回一个布尔值，用于测试构造函数的 prototype 属性是否存在于对象原型链上。所以在判断对象的正确类型时可以考虑使用 instanceof 。 // 定义构造函数function A() &#123;&#125;function B() &#123;&#125;var a = new A()var b = new B()a instanceof A // true ，因为 Object.getPrototypeOf(a) === a.prototypea instanceof B // false ，B.prototype 不在 a 的原型链上 类型转换强制转换Number() 原始类型 —&gt; 数字 // 1. 字符串 ---&gt; 数字 // 1) 可以被解析成数值的字符串 返回 数值 Number('123') // 123 // 2) 不能解析成数值的字符串 返回 NaN Number('123aaa') // NaN // 3) 空串 ---&gt; 0 Number('') // 0// 2. 布尔值 ---&gt; 数字 // 1) true ---&gt; 1 Number(true) // 1 // 2) false ---&gt; 0 Number(false) // 0// 3. undefined ---&gt; NaN Number(undefined) // NaN // 4. null ---&gt; 0Number(null) // 0 在浏览器环境中，window.parseInt() 和 window.parseFloat() 可以将一些字符串转换成数字,但没 Number() 严格 。把其他原始类型都会转换成 NaN 。 parseInt('123aaa') // 123parseFloat('1.23aaa') // 1.23parseInt(true) // NaN 对象 —&gt; 数字 Number() 方法的参数是对象时，除非是包含单个参数的数组会返回数字，否则返回 NaN 。Number(&#123;a: 1&#125;) // NaNNumber([1,2]) // NaNNumber([1]) // 1 在执行 Number(对象) 方法时，会先进行参数处理，将对象转换成原始类型，再进行转换成数字的操作。 第一步，调用对象自身的 valueOf() 方法（ var a = new String(123); a.valueOf() –&gt; ‘123’ ）。如果返回的值是原始类型，则直接将该值转换成数字并返回。不再进行后续步骤。 第二步，如果 valueOf() 方法返回的是对象，则调用原对象自身的 toString() 方法，如果此时返回的值是原始类型，则将该值转换成数字并返回，不再进行后续操作。 如果 toString() 方法返回的还是对象，就报错。 Number(&#123;a: 1&#125;) // NaN// 过程如下：var t = &#123;a: 1&#125;// 第一步t.valueOf() // &#123;a: 1&#125;// 第二步t.toString() // '[object Object]'Number('[object Object]') // NaN Number([1,2])//过程如下：// 第一步[1,2].valueOf() // [1,2]// 第二步[1].toString() // '1,2'Number('1,2') // NaN // 再来看看参数是单个数字的数组时的情况 Number([1]) // 1 //过程如下：// 第一步[1].valueOf() // [1]// 第二步[1].toString() // '1'Number('1') // 1 String() String() 函数可以将任意类型的值转换成字符串。 原始类型 —&gt; 字符串 对象 —&gt; 字符串数组会返回该数组的字符串形式，其他的返回一个类型字符串。 String(&#123;a: 1&#125;) // '[object Object]'String([1,2]) // '1,2'string([]) // '' String(对象) 方法的转换规则与 Number(对象) 基本相同，只是互换了 valueOf() 与 toString() 的执行顺序。 先调用对象的 toString() 方法。如果返回的值是原始类型，则将该值转换成字符串并返回。不再执行以下步骤。 如果 toString() 返回的是对象，则调用原对象的 valueOf() 方法。如果返回的值是原始类型，将该值转换成字符串并返回。不再执行后续操作。 如果 valueOf() 方法返回的还是对象，就报错。 自定义对象的 toString() 方法和 valueOf() 方法：var obj = &#123; valueOf: function() &#123; return 1 &#125;, toString: function() &#123; return 2 &#125;&#125;String(obj) // '2'Number(obj) // 1 Boolean() Boolean() 函数可以将任意类型转换成布尔值除了以下五个值转换结果为 false ，其他值全部转换为 true !!数据 与 Boolean(数据) 效果一样。 undefined null &#39;&#39; (空字符串) -0 或 0 NaN Boolean(undefined) // falseBoolean(null) // falseBoolean('') // falseBoolean(0) // falseBoolean(NaN) // false! NaN // true!! NaN // false 自动转换 自动转换就是没有显式地用函数数据进行类型转换。但它是以强制转换为基础的。 当预期数值与实际数值不匹配时，JavaScript 就会自动调用预期类型的转换函数对实际值进行转换。 进行算术运算 运算子都是原始类型 在加法运算中 只要一方时字符串，另一方就会转换成字符串。字符串拼接。 其他 - * / ** % ++ -- +(一元运算符 表示正数) -(一元运算符 表负数) 都会将运算子转换成数字。1 + '1' // '11'2 * '3' // 61 - 'a' // NaN 3 + - '1' // 2 运算子是对象 会先调用对象的 valueOf() 方法 试图将对象转换成原始类型，如果返回的是对象就再调用原对象的 toString() 方法。将对象转换成原始类型，如果返回的还是对象就报错。 var obj = &#123; valueOf: function() &#123; return '1' &#125;, toString: function() &#123; return '10' &#125;&#125;10 - obj // 91 + [1,2] // '11,2'// [1,2].toString() ---&gt; '1,2' 进行比较运算 === 和 !== 不会发生类型转换，只要类型不同就返回 false. 两边同时为字符串会比较 Unicode 码，否则都会转换成数字进行比较(null、undefined 除外)。 NaN 与任意值(包括本身NaN)比较都返回 false null undefined 除了 null(undefined) == undefined(null) 返回 true，其他 &gt; &lt; == 有 null 或 undefined 参与的都返回 false 。'abc' &gt; 'abd' // falsetrue &gt; false // true ---&gt; Number(true) &gt; Number(false)true &gt; '-1' // true ---&gt; Number(true) &gt; Number('-1')var obj = &#123;valueOf: function() &#123;return '1'&#125;&#125;[3] &gt; obj // true// 过程如下：// Number([3]) &gt; Number(obj)// Number('3') &gt; Number('1')// 3 &gt; 10 == null // false == 常用于判断函数的参数是否等于 null 或者 undefined ，因为 null == undefinded 返回 truefunction fun(x) &#123; if(x == null) &#123;···&#125;&#125; 逻辑运算 !参数 参数&amp;&amp; 参数|| 参数? :(三元运算符) if(参数) 都会将非布尔的参数转换成布尔类型(使用 Boolean(参数) 函数)。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"网络协议总结","slug":"网络协议","date":"2019-03-03T01:38:53.000Z","updated":"2019-03-06T00:28:46.613Z","comments":true,"path":"2019/03/03/网络协议/","link":"","permalink":"inknight.cn/2019/03/03/网络协议/","excerpt":"前端主要关注于应用层 HTTP 协议，传输层 TCP 协议,断舍离一下，就主要总结这两种协议了。","text":"前端主要关注于应用层 HTTP 协议，传输层 TCP 协议,断舍离一下，就主要总结这两种协议了。 OSI 参考模型 与 TCP/IP 五层模型 我们主要关注于 TCP/IP 五层模型 的 应用层 和 传输层 就足够了。 应用层: 作用：为应用程序提供服务。 常见协议：HTTP、HTTPS、FTP、POP3、SMTP等。 传输层: 作用：实现应用程序之间的数据传输。 协议：UDP、TCP UDP 与 TCPUDP UDP 是面向无连接的协议，它只会把数据传递给接收端，但不会关注接收端是否已经正确接收了数据，所以有时候 UDP 会被认为是不可靠的数据报协议。但这种特性反而适合多播，实时的视频和音频传输。 优点： 无需建立连接（减少了延迟） 实现简单（效率高） 头部开销小（ 8 字节） 没有拥塞控制（更好的控制发送时间和速率） 缺点： 没有建立连接（数据想发就发，不可靠） 没有拥塞控制（网络条件不好时会导致丢包） TCP TCP 是面向有连接的协议，在使用 TCP 协议 传输数据之前一定需要在发送方和接收方之间建立连接。建立连接三次握手，断开连接四次挥手~ TCP 建立连接三次握手 第一次握手： 客户端向服务端发送一个 SYN（Seq=X） 包，客户端进入 SYN-SENT 状态，等待服务端的 ACK（Ack=X+1）回复。ps: Seq 是序号，Ack 是确认序号。 第二次握手： 服务端根据接收到客户端发来的 SYN（Seq=X） 包后返回一个 ACK（Ack=X+1） 以及 SYN（Seq=Y） 包给客户端，服务端进入 SYN-RECIVED 状态，等待客户端的 ACK（Ack=Y+1） 回复。 第三次握手： 客户端接收到 ACK（X+1） 后，进入 ESTABLISHED 状态。根据服务端发来的 SYN（Y） 返回一个 ACK（Y+1） 包给服务端。服务端 接收 ACK（Y+1）后进入 ESTABLISHED 状态。此时连接建立成功。 这个过程可以用以下三句形象表示： (客户端)：我想建立连接了，服务端你准备好没有呀？ (服务端)：我准备好了，你准备好没有？ (客户端)：我也准备好了，开始吧~ TCP 关闭连接四次挥手 这个过程可以用以下四句句形象表示： (客户端)：我想关闭连接了。 (服务端)：我知道了。 (服务端)：我现在准备关闭连接了，ok 吗？ (客户端)：ok，你关闭吧。 UDP 与 TCP 的区别 UDP 协议是面向无连接的，它不能保证数据有序且不丢失的传到对端，但是 UDP 比 TCP 更高效。 TCP 协议是面向有连接的，建立和断开连接都需要握手，在传输数据的过程中，通过滑动窗口（流量控制）、拥塞处理（慢开始，拥塞避免，快速重传，快速恢复），能够正确处理丢包问题，保证接收方能够收到数据，与此同时还能够有效利用网络带宽。 HTTP HTTP (HyperText Transfer Protocol) 超文本传输协议 是一个基于 TCP (传输层) 的应用层协议，是客户端与服务端之间请求和响应的标准。 主要特点 简单快速 客户端向服务器请求服务时，只需请求方法和请求路径。 无状态 客户端再次向服务器请求服务时，服务器并不知道客户端之前是否请求过。 无连接 每次请求都会建立一个 TCP 连接，请求处理完成后连接断开。 HTTP 报文 请求行： GET https://www.baidu.com/ HTTP/1.1 由请求方法、URL、协议版本组成 响应行： HTTP/1.1 200 OK协议版本、状态码、状态信息组成 HTTP 请求方法请求方法分为很多种，最常用的也就是 GET 和 POST 了。虽然请求方法很多，但更多的是为了传达语义。更多的方法的语义描述可以阅读 文档 。 GET 和 POST 的区别 GET 能缓存、请求长度限制、 有历史记录 GET 多用于 无副作用(不修改资源)、幂等(请求次数与资源无关)的场景。 POST POST 相对 GET 安全一点点，因为 GET 请求发送的数据包含在 URL 里。 两者详细对比： 状态码 状态码表示了响应的状态，可以让我们知道这一次的请求是成功还是失败，如果失败，是什么原因导致的。 2XX 成功 200 OK ，请求成功并返回数据 204 No Content ，成功但无内容 206 Partial Content ,范围请求 3XX 重定向 301 永久重定向，表示资源已被分配了新的 URL 302 临时重定向，资源临时被分配新的 URL 304 资源未修改，可使用缓存 4XX 客户端错误 400 请求语法错误 401 要求身份认证 403 请求被服务器拒绝 404 资源不存在 5XX 服务器错误 500 服务器错误 503 服务器超负载或停机维护 HTTPS 更安全的网络传输协议 需要安装证书（公钥） 经过 SSL/TLS 协议 加密，传输的内容是经过加密的 使用 443 端口 HTTP/2 多路复用 在同一个 TCP 连接上传输所有的请求数据，避免 队头阻塞(浏览器限制同一个域名下的连接数)问题 Header 压缩 使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，避免 header 重复传输。 二进制传输 在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。 服务端推送 服务端可以在客户端的某个请求后，主动推送其他客户端在之后会用到的资源。省去了客户端重复请求的步骤，降低了延迟。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"计算机网络","slug":"计算机网络","permalink":"inknight.cn/tags/计算机网络/"}]},{"title":"DOM 事件详解","slug":"DOM-事件总结","date":"2019-01-23T14:13:32.000Z","updated":"2019-03-04T00:14:06.206Z","comments":true,"path":"2019/01/23/DOM-事件总结/","link":"","permalink":"inknight.cn/2019/01/23/DOM-事件总结/","excerpt":"事件是 JavaScript 与 HTML 交互的基础。要实现用户与页面的交互，先要对目标元素绑定特定的事件、设置事件处理函数，然后用户触发事件，事件处理函数执行，产生交互效果。","text":"事件是 JavaScript 与 HTML 交互的基础。要实现用户与页面的交互，先要对目标元素绑定特定的事件、设置事件处理函数，然后用户触发事件，事件处理函数执行，产生交互效果。 DOM 事件级别DOM 级别分为四个级别：DOM0 级、DOM1 级、DOM2 级、DOM3 级；DOM 事件级别分为三个级别： DOM0 级事件 &lt;button id=\"btn\" type=\"button\"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn') btn.onclick = function() &#123; console.log('Hello World') &#125; // btn.onclick = null // 解绑事件&lt;/script&gt; 缺点：无法设置多个事件处理函数 DOM2 级事件 &lt;button id=\"btn\" type=\"button\"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); btn.addEventListener('click', showFn, false) btn.addEventListener('click', showFn2, false) // btn.removeEventListener('click', showFn, false) // 解绑事件 function showFn() &#123; alert('Hello World'); &#125; function showFn2() &#123; alert('Hello World2'); &#125; &lt;/script&gt; 可以为事件设置多个事件处理函数，可以通过第三个参数 ( useCapture ) 设置在什么阶段执行事件处理函数，默认是 false， 即在事件冒泡阶段执行事件处理函数。 需要注意的是在 IE8 及以下版本需要用 attachEvent 和 detachEvent 实现，只有两个参数，事件名需要以 on 开头，只支持在事件冒泡阶段执行事件处理函数。 DOM3 级事件 DOM3 级事件是在 DOM2 级事件的基础上添加了更多的事件类型，允许自定义事件。 UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified // 自定义事件var event = new Event('test')// 给元素绑定事件domElement.addEventListener('test', function() &#123; console.log('event test')&#125;,)// 触发事件setTimeout(function() &#123; domElement.dispatchEvent(event)&#125;, 1000) DOM 事件流 想象画在一张纸上的一组同心圆。如果把手指放在圆心上，那么手指指向的不仅仅是一个圆，而是纸上的所有圆。所以如果点击了某个按钮，点击事件不仅仅发生在这个按钮上，整个页面也被点击了。 事件流又称为事件传播，描述的是从页面中接收事件的顺序。DOM2 级事件规定事件流包括三个阶段: 事件捕获(capturing phase)、目标事件(target phase)、事件冒泡(bubbling phase)。发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段 事件冒泡 事件开始时由最具体的元素(目标元素)接收，然后逐级向上传播。 &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: green; &#125; #child &#123; width: 100px; height: 100px; background-color: yellow; &#125;&lt;/style&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;目标元素&lt;/div&gt; 父级元素&lt;/div&gt;&lt;script&gt; var parent = document.getElementById('parent') var child = document.getElementById('child') parent.addEventListener('click', function(e) &#123; console.log('parent bubbling') &#125;, false) child.addEventListener('click', function() &#123; console.log('target bubbling') &#125;, false) document.body.addEventListener('click', function() &#123; console.log('body bubbling') &#125;, false) document.documentElement.addEventListener('click', function() &#123; console.log('html bubbling') &#125;, false) document.addEventListener('click', function() &#123; console.log('document bubbling') &#125;, false) window.addEventListener('click', function() &#123; console.log('window bubbling') &#125;, false)&lt;/script&gt; 运行结果： 事件捕获 事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。 &lt;style&gt; #parent &#123; width: 200px; height: 200px; background-color: green; &#125; #child &#123; width: 100px; height: 100px; background-color: yellow; &#125;&lt;/style&gt;&lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;目标元素&lt;/div&gt; 父级元素&lt;/div&gt;&lt;script&gt; var parent = document.getElementById('parent') var child = document.getElementById('child') parent.addEventListener('click', function(e) &#123; console.log('parent capture') &#125;, true) child.addEventListener('click', function() &#123; console.log('target capture') &#125;, true) document.body.addEventListener('click', function() &#123; console.log('body capture') &#125;, true) document.documentElement.addEventListener('click', function() &#123; console.log('html capture') &#125;, true) document.addEventListener('click', function() &#123; console.log('document capture') &#125;, true) window.addEventListener('click', function() &#123; console.log('window capture') &#125;, true)&lt;/script&gt; 运行结果： 事件对象参数 event 在用户触发事件，执行事件处理函数的时候，默认会向事件处理函数传入一个 event 对象，它记录了该事件的状态和行为。 event 常用属性和方法 type 事件类型 target 事件发出者(触发事件的元素) currentTarget 事件监听者(被绑定事件的元素) stopPropagation() 阻止事件冒泡或捕获 preventDefault() 阻止浏览器默认行为 target 、currentTarget 与 this&lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var parent = document.getElementById('parent') function handler(e) &#123; console.log(e.target) console.log(e.currentTarget) console.log(this) &#125; // 给父盒子注册点击事件 parent.addEventListener('click', handler, false)&lt;/script&gt; 当点击 parent 时，输出： 1 &lt;div id=\"parent\"&gt;...&lt;/div&gt;2 &lt;div id=\"parent\"&gt;...&lt;/div&gt;3 &lt;div id=\"parent\"&gt;...&lt;/div&gt; 当点击 child 时，输出： 1 &lt;div id=\"child\"&gt;...&lt;/div&gt;2 &lt;div id=\"parent\"&gt;...&lt;/div&gt;3 &lt;div id=\"parent\"&gt;...&lt;/div&gt; 所以 target 是事件发出者，curentTarget 是事件监听者，事件处理函数中的 this 等同于 e.currentTarget event 对象的一些兼容性写法 获得 event // 事件处理函数function handleClick(event) &#123; var e = event || window.event ···&#125; 获得 target ···var target = e.target || e.srcElement··· 阻止浏览器默认行为 ···e.preventDefault ? e.preventDefault() : (e.returnValue = false)··· 阻止冒泡 ···e.stopPropagation ? e.stopPropagation() : (e.cancelBubble = true)··· 事件绑定与解绑 function addEvent(element, type, fn) &#123; element.addEventListener ? element.addEventListener(type, fn, false) : element.attachEvent('on'+ type, fn)&#125;function removeEvent(element, type, fn) &#123; element.removeEventListener ? element.removeEventListener(type, fn, false) : element.detachEvent('on'+ type, fn)&#125; 属性表 基础属性 属性 描述 altKey 返回当事件被触发时，”ALT” 是否被按下。 button 返回当事件被触发时，哪个鼠标按钮被点击。 clientX 返回当事件被触发时，鼠标指针的水平坐标。 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 ctrlKey 返回当事件被触发时，”CTRL” 键是否被按下。 metaKey 返回当事件被触发时，”meta” 键是否被按下。 relatedTarget 返回与事件的目标节点相关的节点。 screenX 返回当某个事件被触发时，鼠标指针的水平坐标。 screenY 返回当某个事件被触发时，鼠标指针的垂直坐标。 shiftKey 返回当事件被触发时，”SHIFT” 键是否被按下。 IE 属性 属性 描述 cancelBubble 如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。 fromElement 对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。 keyCode 对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup offsetX,offsetY 发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。 returnValue 如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 false 可以阻止浏览器默认行为 srcElement 对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。 toElement 对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。 x,y 事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。 标准 event 属性（2级 DOM 事件标准定义的属性） 属性或方法 描述 bubbles 返回布尔值，指示事件是否是冒泡事件类型。 cancelable 返回布尔值，指示事件是否可拥可取消的默认动作。 currentTarget 返回其事件监听器触发该事件的元素。 eventPhase 返回事件传播的当前阶段。 target 返回触发此事件的元素（事件的目标节点）。 timeStamp 返回事件生成的日期和时间。 type 返回当前 Event 对象表示的事件的名称。 initEvent() 初始化新创建的 Event 对象的属性。 preventDefault() 通知浏览器不要执行与事件关联的默认动作。 stopPropagation() 不再派发事件（常用于阻止事件冒泡）。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"inknight.cn/tags/HTML/"},{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"CSS盒模型分析","slug":"CSS盒模型分析","date":"2019-01-22T12:15:38.000Z","updated":"2019-03-03T01:05:35.092Z","comments":true,"path":"2019/01/22/CSS盒模型分析/","link":"","permalink":"inknight.cn/2019/01/22/CSS盒模型分析/","excerpt":"CSS 盒模型是前端学习中的基础，总结一下~","text":"CSS 盒模型是前端学习中的基础，总结一下~ 基本概念页面中的每个元素都可以看成一个盒子，盒子里面可以装其他盒子，层层嵌套。html 标签就是最外面的大盒子。每个盒子由内向外分别是 content, padding, border, margin 。 分类盒模型有两种，标准盒模型 和 IE盒模型 。主要区别是它们的 width 和 height 不同 标准盒模型 盒子宽高是 content(内容) 的宽高 IE盒模型 盒子宽高是 border + padding + content 的宽高 浏览器默认使用标准盒模型，在 ie8+ 中 可以通过设置 box-sizing 样式属性改变盒模型box-sizing: content-box —&gt; 标准盒模型（默认） border-box —&gt; IE 盒模型通过 js 获取盒子宽高 以下 domElement 是表示 HTML 元素的伪代码 domElement.style.width/height 只能获取内联样式中的宽高 domElement.currentStyle.width/height 获取的是浏览中渲染完成后元素的宽高，只有 IE 浏览器支持 window.getComputedStyle(domElement).width/height 和方式2一样，但可以兼容更多浏览器 domElement.offsetWidth/offsetHeight 不管使用的什么盒模型，获取的都是 IE盒模型 的宽高 外边距折叠问题 相邻元素在竖直方向上的外边距在相遇时会发生合并，合并后的外边距的高度等于两个外边距中较大的那个值。 兄弟元素间 父子元素间 外边距折叠解决方案（BFC） Block Formatting Context （块级格式化上下文） BFC 可以简单地理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC。 怎样让元素创建 BFC float 的值不为 none （浮动元素） overflow 的值不为 visible display 的值为 inline-block 、table-caption 、 table-cell 、flex 、inline-flex positon 的值为 absolute 或 fixed &lt;html&gt;(根元素) BFC 的布局规则 内部的 box 会在垂直方向上一个接一个地放置 （平时说的块级元素一行行放） box 间垂直方向的距离由 margin 决定 。同一个BFC中的两个相邻的 box 还是会产生外边距重叠问题 BFC 的区域不会与 浮动的 box 重叠 BFC 是一个独立的容器，里面的元素不会影响外面的元素，反之亦然。 包含浮动元素，计算 BFC 的高度时，浮动的元素也会参与计算 BFC 的应用场景 分属于不同 BFC 的元素可以防止垂直外边距折叠 清除内部浮动（使浮动元素可以撑起父盒子） 自适应两栏布局（BFC 区域不会与浮动元素重叠） 防止元素被浮动元素覆盖 float + BFC 两栏布局:&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left &#123; float: left; width: 100px; background-color: blue; &#125; .right &#123; overflow: hidden; /* 触发 BFC */ background-color: green; &#125;&lt;/style&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"inknight.cn/tags/HTML/"},{"name":"基础总结","slug":"基础总结","permalink":"inknight.cn/tags/基础总结/"}]},{"title":"初识Three.js","slug":"初识Three-js","date":"2018-12-28T14:08:15.000Z","updated":"2019-01-04T13:12:12.580Z","comments":true,"path":"2018/12/28/初识Three-js/","link":"","permalink":"inknight.cn/2018/12/28/初识Three-js/","excerpt":"什么是 Three.js ? 简单来看, Three 是 3D 的意思, js 是 JavaScript , 也就是用 JavaScript 开发 3D 的应用程序。","text":"什么是 Three.js ? 简单来看, Three 是 3D 的意思, js 是 JavaScript , 也就是用 JavaScript 开发 3D 的应用程序。 HelloWorld···&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; HelloWorld &lt;/title&gt; &lt;!-- 0. 引入three.js 文件 --&gt; &lt;script src=\"./js/three.js\" &gt;&lt;/script&gt;&lt;/head&gt;··· // 1. 创建场景var scene = new THREE.Scene()// 2. 创建相机var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000)camera.position.z = 5 //设置相机位置// 3. 创建并设置渲染器var renderer = new THREE.WebGLRenderer(&#123;antialias: true&#125;)renderer.setSize(window.innerWidth, window.innerHeight)document.body.appendChild(renderer.domElement)// 4. 创建网格模型添加到场景中var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 1), new THREE.MeshBasicMaterial(&#123;color: 0x00ffff&#125;))scene.add(cube)// 5. 渲染// 设置一个动画函数var animate = function () &#123; // 在浏览器下次重绘前执行回调函数 回调的次数通常是每秒60次 也就是常说的FPS 是60 requestAnimationFrame(animate) // 模型旋转 cube.rotation.x += 0.01 cube.rotation.y += 0.01 //渲染摄像机看见的场景 renderer.render(scene, camera)&#125;animate() 渲染结果： 必要的三个组件场景创建场景： var scene = new THREE.Scene() 场景是所有物体的容器。 相机创建相机： var camera = new THREE.PerspectiveCamera(视口角度, width/height, 视野最近距离, 视野最远距离) 相机就像人的眼睛。 渲染器 创建渲染器： var renderer = new THREE.WebGLRenderer() 设置渲染区域尺寸： renderer.setSize(width, height) 画布添加到页面中： documment.body.appendChild(render.domElement) 渲染器就像视觉神经，缺少它，我们什么也看不见。 坐标系三维坐标系分为两种： 左手坐标系 右手坐标系 在 There.js 中采用的是右手坐标系。 物体旋转的方向 mesh.rotation.y += 0.1 正方向是四指指向的方向","categories":[{"name":"Three.js","slug":"Three-js","permalink":"inknight.cn/categories/Three-js/"}],"tags":[{"name":"WebGL","slug":"WebGL","permalink":"inknight.cn/tags/WebGL/"},{"name":"JavaScript","slug":"JavaScript","permalink":"inknight.cn/tags/JavaScript/"}]},{"title":"HTML笔记","slug":"HTML笔记","date":"2018-10-02T09:48:20.000Z","updated":"2018-12-31T15:26:13.351Z","comments":true,"path":"2018/10/02/HTML笔记/","link":"","permalink":"inknight.cn/2018/10/02/HTML笔记/","excerpt":"HTML初识","text":"HTML初识 Hyper Text Markup Language（超文本标记语言） 用标签来描述网页的结构内容HTML语法骨架： &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;!-- 还可以插入其他meta、样式单等信息 --&gt;&lt;/head&gt;&lt;body&gt;页面内容部分&lt;/body&gt;&lt;/html&gt;&lt;!-- 注意：不要在&lt;html&gt;和&lt;head&gt;之间插入任何内容 &lt;/head&gt;和&lt;body&gt; &lt;/body&gt;和&lt;/html&gt; 之间插入内容--&gt; HTML 标签HTML 元素&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;a href=\"#\"&gt;This is a link&lt;/a&gt;&lt;br /&gt; 开始标签 元素内容 结束标签 &lt;p&gt; This is a paragraph &lt;/p&gt; &lt;a href=&quot;#&quot;&gt; This is a link &lt;/a&gt; &lt;br /&gt; HTML 元素指的是从开始标签到结束标签的所有代码 HTML 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数HTML元素可拥有属性 排版标签 标题标签 &lt;h1&gt;&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h3&gt;&lt;/h3&gt; &lt;h4&gt;&lt;/h4&gt; &lt;h5&gt;&lt;/h5&gt; &lt;h6&gt;&lt;/h6&gt; 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。一般h1都是给logo使用，或者页面中最重要标题信息。 段落标签 &lt;p&gt;文本内容&lt;/p&gt; 水平线标签（horizontal） &lt;hr /&gt; &lt;!-- 在html5里可以写成&lt;hr&gt; 单标签(空元素)可以省略结束标签--&gt; 换行标签（break） &lt;br /&gt; 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 div span标签 &lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; &lt;!-- 不在同一行 --&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt; &lt;!-- 在同一行 --&gt; &lt;div&gt;元素是块级元素，它是可用于组合其他 HTML 元素的容器。&lt;div&gt;元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。&lt;span&gt;元素是内联元素，可用作文本的容器&lt;span&gt;元素也没有特定含义。内联元素在显示时通常不会以新行开始。 文本格式化标签 标签 作用 &lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt; 粗体 &lt;i&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; 斜体 &lt;s&gt;&lt;/s&gt; &lt;del&gt;&lt;/del&gt; 删除线 &lt;u&gt;&lt;/u&gt; &lt;ins&gt;&lt;/ins&gt; 下划线 strong em del ins 语义更强烈 图像标签&lt;img src=\"图像的URL\" alt=\"图像不能显示时的替换文字\" title=\"鼠标悬停的显示内容\" width=\"\" height=\"\" border=\"\"/&gt; 链接标签&lt;a href=\"跳转目标\" target=\"定义被链接的文档在何处显示\"&gt;文本或图片&lt;/a&gt; 锚点定位 1.使用&lt;a href=&quot;#(id名)&quot;&gt;链接&lt;/a&gt;创建一个链接。&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;2.使用相应的id名标注跳转的目标位置。&lt;h3 id=&quot;two&quot;&gt;第二集&lt;/h3&gt; 将 # id名添加到URL的末端，就可以直接跳转到指定页面的指定位置。 base 标签···&lt;head&gt;···&lt;base target=\"_blank\" /&gt;&lt;base href=\"http://www.w3school.com.cn\" /&gt;···&lt;/head&gt;··· &lt;base&gt;标签为页面上所有链接规定默认地址或目标 标签必须位于 head 元素内部 列表标签 无序列表 &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; ···&lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; ···&lt;/ol&gt; 自定义列表 &lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ··· &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ··· ···&lt;/dl&gt; 表格标签&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;td&gt; ··· &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; ··· &lt;/tr&gt; ···&lt;/table&gt; 表格属性 属性名 含义 默认值 border 表格边框 0px cellspacing 单元格与单元格边框之间的距离 2px cellpadding 单元格内容与边框的距离 1px width 表格宽度 height 表格高度 align 表格在网页水平对齐方式 left(/center/right) 表头标签 表头单元格一般位于表格的第一行或第一列，其文本默认加粗居中。用&lt;th&gt;&lt;/th&gt;替换&lt;td&gt;&lt;/td&gt;即可将普通单元格换成表头单元格 表格结构&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; ··· &lt;/tr&gt; ··· &lt;/tbody&gt;&lt;/table&gt; 合并单元格 跨行合并：rowspan 跨列合并：colspan 1.先确定是跨行还是跨列 2.根据先上后下，先左后右找到目标单元格 3.合并后删除多余单元格 表单标签一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件： 包含了具体的表单功能项，如单行文本输入框、密码输入框、单选框、复选框、提交按钮、重置按钮等。 提示信息：给用户看的信息 表单域：一个容纳表单信息和表单控件的容器，可以定义处理表单数据所用程序的URL地址，以及数据提交到服务器的方法。没有表单域，表单中的数据就无法送达到服务器。 表单域&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单名称\"&gt;&lt;!-- 各种表单控件 --&gt;&lt;/form&gt; input标签属性： label标签&lt;form&gt; &lt;label for=\"male\"&gt;Male&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"male\" /&gt; &lt;br /&gt; &lt;label for=\"female\"&gt;Female&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"female\" /&gt;&lt;/form&gt; 作用：在label元素里点击后会触发此控件，让浏览器将焦点转到label中for绑定的id的表单控件上 textarea标签（文本域）&lt;textarea cols=\"每行中的字符数\" row=\"显示的行数\"&gt;文本内容&lt;textarea&gt; select标签（下拉菜单）&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ···&lt;/select&gt; 1.select元素中至少应包含一个&lt;option&gt;&lt;/option&gt; 2.在option 中定义select=”selected”属性时，当前选项为默认值。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"inknight.cn/categories/Web前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"inknight.cn/tags/HTML/"}]}]}